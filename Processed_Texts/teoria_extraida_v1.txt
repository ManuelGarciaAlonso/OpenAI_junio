# Resultados del Preprocesamiento de PDFs de Teor√≠a (2025-04-10 17:04:49)
Directorios escaneados: ['/mnt/c/Users/34644/Desktop/TFM/FS/Teoria', '/mnt/c/Users/34644/Desktop/TFM/FS/BoletinesEjercicios', '/mnt/c/Users/34644/Desktop/TFM/FS/Pr√°cticas']



## üìÑ Archivo: [Teor√≠a] Tema1.pdf

**M√©todo de extracci√≥n usado:** Docling

```markdown
## Tema 1. Sistema de C√≥mputo



- 1.1 Componentes de un Sistema de C√≥mputo.
- 1.1.1 Definiciones B√°sicas.
- 1.1.2 Registros del Procesador.
- 1.1.3 Ejecuci√≥n de Instrucciones. Tipos de Instrucciones.
- 1.2 Capa Hardware.
- 1.2.1 Estructura de un Ordenador.
- 1.2.2 T√©cnicas de Comunicaci√≥n de E/S.
- 1.3 El Sistema Operativo.
- 1.4 Utilidades del Sistema.

## Bibliograf√≠a b√°sica

[Prie06]

A. Prieto, A. Lloris, J.C. Torres, Introducci√≥n a la Inform√°tica , McGraw-Hill, 2006

[Stal05]

W. Stallings, Sistemas Operativos, Aspectos Internos y Principios de Dise√±o (5¬™ Edici√≥n) . Pearson Education, 2005

[Carr07]

J. Carretero, F. Garc√≠a, P. de Miguel, F. P√©rez, Sistemas Operativos (2¬™ Edici√≥n) , McGraw-Hill, 2007

Curso 2019-20

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

Fundamentos del Software

1er Curso de Grado en Ingenier√≠a Inform√°tica



- ¬∑ Conocer los elementos principales de un Sistema de C√≥mputo.
- ¬∑ Disponer los elementos de la parte hardware.
- ¬∑ Conocer el software m√°s pr√≥ximo a la capa hardware: el Sistema Operativo.
- ¬∑ Conocer las principales utilidades software que se utilizan en un sistema de c√≥mputo.

## 1.1 Componentes de un Sistema de C√≥mputo

## Definiciones B√°sicas [Prie06] (pp.1-7)

- ‚Ä¢ Inform√°tica, Computador, Bit, ‚Ä¶
- ‚Ä¢ Instrucci√≥n u Orden, Programa, Lenguaje de Programaci√≥n.
- ‚Ä¢ Lenguaje M√°quina.
- ‚Ä¢ Hardware (soporte f√≠sico) y Firmware.
- ‚Ä¢ Software (soporte l√≥gico).
- ‚Ä¢ Sistema Inform√°tico.

‚Ä¢ ‚Ä¶

Tema 1. Sistema de C√≥mputo

## 1.1 Componentes de un Sistema de C√≥mputo

## Definici√≥n de Bit

- ¬∑ Bit ( Bi nari Digi ): unidad m√≠nima de informaci√≥n t
- ‚Ä¢ Codifica informaci√≥n:
- ‚Ä¢ 1 bit: 0 √≥ 1
- ‚Ä¢ 2 bits: 00, 01, 10 √≥ 11
- ‚Ä¢ ‚Ä¶
- ‚Ä¢ 2 n¬∫ de bits

= elementos

- ¬∑ Log 2 elementos = n¬∫ de bits







False 1 0 True

Tema 1. Sistema de C√≥mputo

## M√∫ltiplos del bit y Unidades de medida

- ¬∑ 1 Byte (B) = 8 bits (b)   (Byte: Unidad m√≠nima para direccionar)

| Bytes                       | bits                       |
|-----------------------------|----------------------------|
| 1 Kilobyte (KB) = 2 10 B    | 1 Kilobit (Kb) = 2 10 bits |
| 1 Megabyte (MB) = 2 10 KB   | 1 Megabit (Mb) = 2 20 bits |
| 1 Gigabyte (GB) =  2 10 MB  | 1 Gigabit (Gb) = 2 30 bits |
| 1 Terabyte (TB) =   2 10 GB | 1 Terabit (Tb) = 2 40 bits |
| 1 Petabyte (PB) =   2 10 TB | 1 Petabit (Pb) = 2 50 bits |

## Cambio de base: binario, octal, hexadecimal [Prie06] (Ap√©ndice A. pp.767)

|                                                                                        |   0 |   1 |   2 |   3 |   4 | 5                                                                         |   6 |   7 | 8   | 9   | 10   | 11   | 12                                                                         | 13   | 14   | 15   | 16   |
|----------------------------------------------------------------------------------------|-----|-----|-----|-----|-----|---------------------------------------------------------------------------|-----|-----|-----|-----|------|------|----------------------------------------------------------------------------|------|------|------|------|
| ‚Ä¢ Binario Binario (N ) 2                                                               | 000 | 001 | 010 | 011 | 100 | : 000, 001, 010, 011, 100, 101, 110, 111 101                              | 110 | 111 |     |     |      |      |                                                                            |      |      |      |      |
| ‚Ä¢ Octal : 00, 01, 02, 03, 04, 05, 06, 07, 10, 11, 12, 13, 14, ... Decimal Octal (N ) 8 |  00 |  01 |  02 |  03 |  04 | 05                                                                        |  06 |  07 | 10  | 11  | 12   | 13   | 14                                                                         | 15   | 16   | 17   | 20   |
| ‚Ä¢ ‚Ä¢ Hexadecimal Decimal (N 10 )                                                        |  00 |  01 |  02 |  03 |  04 | : 00, 01, 02, 03, 04, 05, 06, 07, 08, 09, 0A, 0B, 0C, 0D, 0E, 0F, 10,  05 |  06 |  07 | 08  | 09  | 10   | 11   | : 00, 01, 02, 03, 04, 05, 06, 07, 08, 09, 10, 11, 12, 13, 14, 15, 16, ‚Ä¶ 12 | 13   | 14   | 15   | 16   |
| 11, ‚Ä¶ Hexadecimal (N 16 )                                                              |  00 |  01 |  02 |  03 |  04 | 05                                                                        |  06 |  07 | 08  | 09  | 0A   | 0B   | 0C                                                                         | 0D   | 0E   | 0F   | 10   |

N'base 10 = d√≠gito0 √ó base 0 + d√≠gito1 √ó base 1 + ‚Ä¶ + d√≠giton √ó base n

Para obtener el n√∫mero en otra base: dividir hasta llegar a un cociente menor que la base y tomar los restos y el √∫ltimo cociente de la divisi√≥n.

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

## 1.1 Componentes de un Sistema de C√≥mputo

## Instrucciones vs. Datos

- ‚ö´ Instrucci√≥n : conjunto de s√≠mbolos insertados en una secuencia estructurada o espec√≠fica que el procesador interpreta y ejecuta.
- ‚ö´ Datos : S√≠mbolos que representan hechos, condiciones, situaciones o valores. Elementos de informaci√≥n.

## Instrucciones vs. Datos (cont.)

- ‚ö´ Lenguaje natural:

Suma lo que hay en A con lo que tiene la posici√≥n 17 de una secuencia de valores.

- ‚ö´ Lenguaje de programaci√≥n de alto nivel:

A= A + M[17]

- ‚ö´ Ensamblador y lenguaje m√°quina:

ADD A, M(17)     ‚Üí     11000   001  0001  001111

C√≥digo de

operaci√≥n

Campos de

direcciones

A

Acumula

M

17



DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

1er Curso de Grado en Ingenier√≠a Inform√°tica

1er Curso de Grado en Ingenier√≠a Inform√°tica

## Instrucciones vs. Datos (cont.)

## ‚ö´ Lenguaje natural:



## Action:

INFORY

Transport:

taxi

Time:

18 : 25

Cost:

20‚Ç¨

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

## Instrucciones vs. Datos (cont.)

- ‚ö´ Lenguaje de programaci√≥n de alto nivel:



DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

1er Curso de Grado en Ingenier√≠a Inform√°tica

## Instrucciones vs. Datos (cont.)

- ‚ö´ Lenguaje de programaci√≥n de alto nivel:



1er Curso de Grado en Ingenier√≠a Inform√°tica

## Instrucciones vs. Datos (cont.)



## Hardware (Soporte F√≠sico)



DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

## Firmware

Bloque de instrucciones de m√°quina para prop√≥sitos espec√≠ficos grabado en una memoria, normalmente de lectura/escritura que establece la l√≥gica de m√°s bajo nivel que controla los circuitos electr√≥nicos de un dispositivo de cualquier tipo.







DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

## Software (Soporte L√≥gico)

Conjunto de programas, instrucciones y reglas inform√°ticas que permiten ejecutar distintas tareas en una computadora (RAE).





DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

Tema 1. Sistema de C√≥mputo

## Definiciones B√°sicas [Stal05] (pp.55)



DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_



## Arquitectura de un Sistema



DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

## 1.2 Capa Hardware

## Registros del Procesador [Stal05] (pp.11-13)

- ‚Ä¢Registros visibles para el programador.
- ‚Ä¢Registros de control y estado:
- o Contador de programa (PC).
- o Puntero de pila (SP).
- o Registro de instrucci√≥n (IR).
- o Registro de estado (bits informativos).

## Esquema del microporces ador 8088





## Ejecuci√≥n de Instrucciones [Stal05] (pp.14-17)

Procesar una instrucci√≥n consta de dos pasos:

- 1. El Procesador lee (busca) instrucciones de la memoria, una cada vez.
- 2. El Procesador ejecuta cada instrucci√≥n.

Se denomina ciclo de instrucci√≥n al procesamiento requerido por una √∫nica instrucci√≥n.

La ejecuci√≥n de un programa consiste en repetir el proceso de b√∫squeda y ejecuci√≥n de instrucciones.



## Proceso a seguir:

- 1. Se lee la instrucci√≥n cuya direcci√≥n est√° en el PC.
- 2. Se incrementa el PC en una unidad.
- 3. Se ejecuta la instrucci√≥n.

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_



## Repertorio elemental de instrucciones [Stal05] (pp.14-17)

Podemos clasificarlas en:

- ¬∑ Transferencia de datos:

MOV origen, destino

- ¬∑ Aritm√©tico-l√≥gicas:

ADD op1, op2, resultado COMP Ri, Rj MULT op1, op2, resultado

‚Ä¶

- ¬∑ Entradas/salidas:

IN puerto, destino OUT origen, puerto

- ¬∑ Control:

JUMP/JNE/JE etiqueta CALL funci√≥n RETURN e IRETURN HALT

‚Ä¶

Tema 1. Sistema de C√≥mputo

## Repertorio elemental de instrucciones [Stal05] (pp.14-17)

Ejemplo : Sumar dos n√∫meros cargados en memoria en las direcciones direc1 y direc2 y poner el resultado en direc3.

MOV direc1, R0 MOV direc2, R1 ADD R0, R1, R2 MOV R2, direc3 HALT

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

## Ejecuci√≥n del ejemplo (paso 0)



## Ejecuci√≥n del ejemplo (paso 1)

LENGUAJES Y SISTEMAS INFORM√ÅTICOS



## Ejecuci√≥n del ejemplo (paso 2)



## Ejecuci√≥n del ejemplo (paso 3)

LENGUAJES Y SISTEMAS INFORM√ÅTICOS



## Ejecuci√≥n del ejemplo (paso 4)



## Ejecuci√≥n del ejemplo (paso 5)



## Ejecuci√≥n de Instrucciones [Stal05] (pp.14-17)

- ¬∑ Ejemplo: Sumar los n√∫meros de la posici√≥n 940 y 941 y dejar el resultado en la posici√≥n 941.
- 1. El contador del programa (PC) tiene el valor 300 (la direcci√≥n de la primera instrucci√≥n). Se lleva a IR la instrucci√≥n y se incrementa PC en una unidad.
- 2. Se ejecuta la instrucci√≥n. (Los primeros 4 bits -d√≠gitos en hexadecimal- en el IR indican que el AC ser√° cargado desde memoria; los siguientes 12 bits -tres d√≠gitos en hexadecimal- indican la direcci√≥n, 940).
- 3. La siguiente instrucci√≥n (5941) ser√° captada desde la direcci√≥n 301. El PC se incrementa.
- 4. El anterior contenido del AC y el contenido de la direcci√≥n 941 se suman y el resultado se almacena en el AC.
- 5. La siguiente instrucci√≥n (2941) ser√° captada desde la direcci√≥n 302. El PC se incrementa.
- 6. El contenido del AC se aloja en la direcci√≥n 941.

Imagen obtenida de [Stal05] pp.16



## 1.2 Capa Hardware

Fundamentos del Software

Tema 1. Sistema de C√≥mputo

## Ejecuci√≥n de Instrucciones [Stal05] (pp.34-37)

¬øQu√© sucede cuando un programa desea comunicarse con alg√∫n dispositivo de E/S?

## ‚Üí Comunicaciones de E/S

Hay tres t√©cnicas para llevar a cabo las operaciones de E/S:

- ‚Ä¢ E/S Programada.
- ‚Ä¢ E/S Dirigida por Interrupciones.
- ‚Ä¢ Acceso Directo a Memoria (Direct Memory Access, DMA).

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

## T√©cnicas de Comunicaci√≥n de E/S

- ¬∑ E/S Programada. El procesador encuentra una instrucci√≥n con la E/S. Se genera un mandato al m√≥dulo de E/S apropiado.

El procesador adopta un papel activo mientras se atiende la instrucci√≥n de E/S y comprueba peri√≥dicamente el estado de la ejecuci√≥n del m√≥dulo de E/S hasta que ha finalizado la operaci√≥n.

Problema : El procesador pasa mucho tiempo esperando la finalizaci√≥n del m√≥dulo de E/S y el sistema se degrada gravemente.

Soluci√≥n : Mientras se atiende al m√≥dulo de E/S, se intenta que el procesador pueda continuar con trabajo √∫til.



## 1.2 Capa Hardware

## T√©cnicas de Comunicaci√≥n de E/S

## ¬∑ E/S Dirigida por Interrupciones.

Evento que interrumpe el flujo normal de ejecuci√≥n y que est√° producido por un elemento externo al procesador.

de EIS

No listo

Comprueba

Fundamentos del Software

1er Curso de Grado en Ingenier√≠a Inform√°tica

CPU

del m√≥dulo de ElS

EIS

CPU

Condici√≥n

Es un evento as√≠ncrono.

el estado de error

Listo

Problema : En transferencias considerables de memoria a dispositivo o viceversa conlleva un uso excesivo del procesador. Escribe la

CPU

palabra en memolia

Soluci√≥n : Acceso Directo a Memoria. En un solo mandato se genera todo lo necesario para realizar la transferencia de informaci√≥n de memoria al dispositivo o viceversa.

Comprueba elestado

Listo

Lee una palabra del

m√≥dulo de ES

Escribe la memoria

palabra en

No

S√≠

Siguiente instrucci√≥n

(Completado?

S√≠

Siguiente instrucci√≥n

Imagen obtenida de [Stal05] pp.35

Condici√≥n de error

S:

(c) Ac

CPU

CPU

memoria

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_



## T√©cnicas de Comunicaci√≥n de E/S

## ¬∑ Ciclo de instrucci√≥n con interrupciones.



Tema 1. Sistema de C√≥mputo

Tema 1. Sistema de C√≥mputo

## Tratamiento de Interrupciones Vectorizadas



## 1.2 Capa Hardware

Tratamiento de Interrupciones

Vectorizadas [Stal05] (pp. 23. Fig. 1.10)

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

Hardware

El controlador de disp. u otro sistema hardware

genera una interrupci√≥n

El procesador termina la ejecuci√≥n de la

instrucci√≥n actual

El procesador indica el reconocimiento de la

interrupci√≥n

El procesador apila

PSW y el PC en la pila de control

El procesador carga un nuevo valor en el PC

basado en la interrupci√≥n

Fundamentos del Software

1er Curso de Grado en Ingenier√≠a Inform√°tica

Sontware

Salva el resto de la informaci√≥n de estado

del proceso

Procesa la interrupci√≥n

Restaura la informaci√≥n de estado

del proceso

Restaura los valores

PSW y PC

## T√©cnicas de Comunicaci√≥n de E/S [Stal05] (pp.34-37)

- ¬∑ Acceso Directo a Memoria (DMA, Direct Access Memory). Realizada por un m√≥dulo separado conectado en el bus del sistema o incluida en un m√≥dulo de E/S. √ötil cuando el procesador desea leer o escribir un bloque de datos.



Imagen obtenida de [Stal05] pp.35

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

## Excepciones [Stal05] (pp.34-37)

- ¬∑ Definici√≥n de excepci√≥n: Evento inesperado generado por alguna condici√≥n que ocurre durante la ejecuci√≥n de una instrucci√≥n (ejemplo, desbordamiento aritm√©tico, direcci√≥n inv√°lida, instrucci√≥n privilegiada, etc.). Es un evento s√≠ncrono.

## Protecci√≥n del procesador [Carr07] (pp.26)

Funcionamiento en Modo Dual. ¬øQu√© ocurre si un programa accede a la memoria donde se alojan los vectores de interrupciones? ¬øQu√© pasa si las modifica?

Soluci√≥n: El procesador dispone de diferentes modos de ejecuci√≥n de instrucciones:

- ¬∑ Instrucciones privilegiadas (modo supervisor/kernel): Aquellas cuya ejecuci√≥n puede interferir en la ejecuci√≥n de un programa cualquiera o programa del SO (ejemplo, escribir en el puerto de un dispositivo).
- ¬∑ Instrucciones no privilegiadas (modo usuario): Aquellas cuya ejecuci√≥n no presenta ning√∫n problema de seguridad para el resto de programas (ejemplo, incrementar un contador).

## 1.2 Capa Hardware

## Protecci√≥n de los Dispositivos de E/S [Carr07] (pp.27-28)

- ¬∑ Los dispositivos de E/S son recursos que han de estar protegidos (ejemplo, los archivos, las impresoras, ‚Ä¶)
- ¬∑ ¬øC√≥mo se consigue? ‚Üí Las instrucciones m√°quina  para acceso a los dispositivos de E/S no pueden ejecutarse en modo usuario: son privilegiadas.
- ¬∑ Cualquier acceso a los dispositivos desde un programa de usuario se har√° mediante peticiones al SO.

## Protecci√≥n de Memoria [Carr07] (pp.26-27)

- ¬∑ Cada programa en ejecuci√≥n requiere de un espacio de memoria.
- ¬∑ Objetivo: Hay que proteger la zona de memoria asignada y la memoria en la que est√° el c√≥digo del sistema operativo (tabla de vectores de interrupci√≥n, rutinas de tratamiento de cada interrupci√≥n).

## 1.3 El Sistema Operativo

Fundamentos del Software

Tema 1. Sistema de C√≥mputo

## El Sistema Operativo [Stal05] (cap.2, pp.53-120)

Un SO es un programa o conjunto de programas que controla la ejecuci√≥n de los programas de aplicaci√≥n y que act√∫a como interfaz entre el usuario de una computadora y el hardware de la misma.



DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

## El SO como interfaz Usuario/Computadora

Presenta al usuario una m√°quina abstracta m√°s f√°cil de programar que el hardware subyacente:

- ¬∑ Oculta la complejidad del hardware.
- ¬∑ Da tratamiento homog√©neo a diferentes objetos de bajo nivel (archivos, procesos, dispositivos, etc.).

Una aplicaci√≥n se puede expresar en un lenguaje de programaci√≥n y la desarrolla un programador de aplicaciones.

Es m√°s f√°cil programar las aplicaciones en lenguajes de alto nivel que en el lenguaje m√°quina que entiende el hardware.

## El SO como interfaz Usuario/Computadora

Un SO proporciona normalmente utilidades en las siguientes √°reas:

- ¬∑ Desarrollo de programas (editores de texto, compiladores, depuradores de programas).
- ¬∑ Ejecuci√≥n de programas (cargador de programas y ejecuci√≥n de √©stos).
- ¬∑ Acceso a dispositivos de E/S (cada dispositivo requiere su propio conjunto de instrucciones).

## El SO como interfaz Usuario/Computadora

(cont.)

- ¬∑ Acceso al sistema (En sistemas compartidos o p√∫blicos, el SO controla el acceso y uso de los recursos del sistema: Shell, Interfaz gr√°fico).
- ¬∑ Detecci√≥n y respuesta a errores (tratamiento de errores a nivel software y hardware).
- ¬∑ Contabilidad (estad√≠sticas de uso de los recursos y medida del rendimiento del sistema).

## El SO como Administrador de Recursos

Un computador es un conjunto de recursos y el SO debe gestionarlos y para ello posee un mecanismo de control que cubre dos aspectos:

- ¬∑Las funciones del SO act√∫an de la misma forma que el resto del software, es decir, son programas ejecutados por el procesador.
- ¬∑El SO frecuentemente cede el control y depende del procesador para volver a retomarlo.



## El SO como Administrador de Recursos

## Por lo tanto:

- ¬∑El SO dirige al procesador en el uso de los recursos del sistema y en la temporizaci√≥n de la ejecuci√≥n de otros programas.
- ¬∑Una parte del c√≥digo del SO se encuentra cargado en la memoria principal (kernel y, en ciertos momentos, otras partes del SO que se est√©n usando). El resto de la memoria est√° ocupada por programas y datos de usuario.
- ¬∑La asignaci√≥n de la memoria principal la realizan conjuntamente el SO y el hardware de gesti√≥n de memoria del procesador.
- ¬∑El SO decide cu√°ndo un programa en ejecuci√≥n puede usar un dispositivo de E/S y tambi√©n el acceso y uso de los ficheros. El procesador es tambi√©n un recurso.

## Caracter√≠sticas deseables en un Sistema Operativo

- ¬∑ Comodidad en el uso.
- ¬∑ Eficiencia : Existen m√°s programas que recursos. Hay que repartir los recursos entre los programas.
- ¬∑ Facilidad de Evoluci√≥n : Un SO importante debe evolucionar en el tiempo por las siguientes razones:
- ¬∑ Actualizaciones del hardware y nuevos tipos de hardware.
- ¬∑ Mejorar y/o aportar nuevos servicios.
- ¬∑ Resoluci√≥n de fallos.

## 1.4 Utilidades del Sistema

## Programas de Servicio del SO [Prie06] (Cap.13, secci√≥n 13.1, pp.518-520)

Se trata de un conjunto de programas de servicio que, en cierta medida, pueden considerarse como una ampliaci√≥n del SO:

- ‚Ä¢ Compactaci√≥n de discos.
- ‚Ä¢ Compresi√≥n de datos.
- ‚Ä¢ Gesti√≥n de comunicaciones.
- ‚Ä¢ Navegadores de internet.
- ‚Ä¢ Respaldo de seguridad.
- ‚Ä¢ Recuperaci√≥n de archivos eliminados.
- ‚Ä¢ Antivirus.
- ‚Ä¢ Salvapantallas.
- ‚Ä¢ Interfaz gr√°fica.

## 1.4 Utilidades del Sistema

## Herramientas Generales

Su misi√≥n es facilitar la construcci√≥n de las aplicaciones de los usuarios, sea cual sea la naturaleza de √©stas, tales como:

- ‚Ä¢ Editores de texto.
- ‚Ä¢ Compiladores.
- ‚Ä¢ Int√©rpretes.
- ‚Ä¢ Enlazadores.
- ‚Ä¢ Cargadores/Montadores.

‚Ä¢ ‚Ä¶
```



## üìÑ Archivo: [Teor√≠a] Tema4-BD-EntidadRelacion.pdf

**M√©todo de extracci√≥n usado:** Docling

```markdown
## 1. Modelo entidad-relaci√≥n

Hasta 1970 las bases de datos utilizaban para almacenar la informaci√≥n, registros unidos a trav√©s de lo que se denomin√≥ ligas o apuntadores, que no era m√°s que una direcci√≥n f√≠sica que serv√≠a para identificar   d√≥nde   podr√≠a   encontrarse   el   registro   en   el   disco.   Por   aquellas   fechas   E.F.   Cood (argumentaba   que   los   datos   deber√≠an   relacionarse   mediante   interrelaciones   naturales,   l√≥gicas, inherentes a los datos, m√°s que mediante punteros f√≠sicos.

A continuaci√≥n   se   pasa   a   explicar   ciertos   conceptos   relacionados   con   esta   nueva   forma   de representar la informaci√≥n en una base de datos.

## Entidad:

Una entidad es un objeto concreto que existe, que puede distinguirse de otros y del cual se desea almacenar informaci√≥n en la base de datos. Se denomina 'tipo de entidad' a la estructura gen√©rica, mientras que por 'entidad'se entiende cada una de las ocurrencias del tipo 'tipo de entidad' que existen en la base de datos.

Una entidad debe:

- ÔÇ∑ Tener existencia propia.
- ÔÇ∑ Cada ocurrencia de un tipo entidad debe poder distinguirse de las dem√°s ocurrencias.
- ÔÇ∑ Todas las ocurrencias de un tipo de entidad deben de tener las mismas caracter√≠sticas.

Ejemplo: Alumno

## Conjunto de Entidades:

Es un conjunto de entidades del mismo tipo. Los conjuntos de entidades no tienen porque ser siempre disjuntos.

Ejemplo: Supongamos que tenemos los empleados de un banco y los clientes. Puede darse el caso en el que un empleado sea a la vez, cliente del banco en el que trabaja.

## Atributos

Un atributo es la unidad b√°sica de informaci√≥n acerca de un tipo de entidad o de un tipo de relaci√≥n.

Ejemplo: Atributos de la entidad alumno podr√≠an ser los siguientes:

Nombre, Apellido1, Apellido2, D.N.I., Direcci√≥n, Tel√©fono.

La informaci√≥n de cada entidad se almacena f√≠sicamente en un registro y cada uno de los campos del registro se corresponde con un atributo de la entidad.

## Dominio de un atributo

Conjunto de valores permitidos para un atributo, por ejemplo datos de tipo entero, real, l√≥gico, fecha, rangos definidos por el usuario, etc.

Ejemplo: Sup√≥ngase que queremos definir el dominio de los d√≠as de la semana. Ser√≠an valores posibles los siguientes: Lunes, Martes, Mi√©rcoles, Jueves, Viernes, S√°bado y Domingo.

## Llave Primaria

De entre todos los atributos que definen a una entidad, se han de elegir uno o varios para  identificar de forma un√≠voca a la entidad. Este atributo recibe el nombre de superllave o superclave.   La superllave m√≠nima elegida por el admimistrador de la base de datos se llama Llave primaria.

## Relaci√≥n

Las entidades por s√≠ solas no describen la realidad de un sistema de informaci√≥n. No basta con identificar   objetos,  es   necesario   establecer   las   asociaciones   existentes   entre   ellos.   Para   ello   se introduce el concepto de relaci√≥n. Se define la relaci√≥n como una asociaci√≥n o correspondencia que se establece entre entidades del mismo tipo.

Ejemplo: Libro relacionado con autor. La posible relaci√≥n establecida entre las dos entidades ser√≠a 'escrito'.

El dise√±ador de la base de datos podr√° utilizar verbos, preposiciones, o bien el nombre de las dos entidades separadas por un gui√≥n para representar la relaci√≥n existente entre dos entidades.

La relaci√≥n a la que nos hemos referido anteriormente podr√≠a expresarse a trav√©s de:

- ÔÇ∑ Escrito por
- ÔÇ∑ De
- ÔÇ∑ Libro-Autor

## Grado de una relaci√≥n

Es el n√∫mero de tipos de entidad que participan en un tipo de relaci√≥n concreta.

## Tipo de correspondencia

El tipo de correspondencia expresa el n√∫mero m√°ximo de ocurrencias que le pueden corresponder a un tipo de entidad del otro tipo de entidad en la interrelaci√≥n concreta que entre ellos se establezca. La correspondencia se etiqueta seg√∫n los casos:

- ÔÇ∑ 1:1 ( correspondencia de 1 a 1)
- ÔÇ∑ 1:N ( correspondencia de 1 a N o de 1 a muchos)
- ÔÇ∑ N: M ( correspondencia de N a M o de muchos a muchos)

## Correspondencia 1:1

Cuando a cada ocurrencia de una entidad le puede corresponder no m√°s de una del otro tipo de entidad y a la inversa.

Ejemplo: Sup√≥ngase que se quiere representar en una sociedad en la que no que est√© permitida la poligamia, la relaci√≥n de matrimonio. Necesitar√≠amos dos entidades: mujer y hombre asociadas a trav√©s de la relaci√≥n casada con. En este caso la relaci√≥n establecida entre las entidades tiene una correspondencia 1:1, significando que una mujer puede estar casada con uno y s√≥lo un hombre y un hombre a su vez, tan s√≥lo puede estar casado con una y s√≥lo una mujer.

## Correspondencia 1: N

La correspondencia 1: N significa que a cada ocurrencia del primer tipo de entidad le pueden corresponder varias ocurrencias del segundo tipo de entidad y a √©sta, a su vez, no m√°s de una del primero.

Ejemplo: Se desea representar la informaci√≥n sobre las asignaturas que hay en un determinado curso, para ello se dispone de dos entidades: curso y asignatura. En este caso la relaci√≥n establecida entre las dos entidades tendr√° cardinalidad 1: N ya que dado un curso existir√°n distintas asignaturas para dicho curso.

## Correspondencia N: M

El √∫ltimo tipo de correspondencia posible es N: M, significando lo siguiente: a cada ocurrencia del primer tipo de entidad le pueden corresponder varias ocurrencias del segundo tipo de entidad y viceversa.

Ejemplo: Se desea representar la informaci√≥n sobre las pel√≠culas realizadas por los actores. En este caso la relaci√≥n establecida entre las dos entidades (pel√≠culas y actores) ser√°n del grado N: M, ya que se supone que un determinado actor puede hacer varias pel√≠culas y en una pel√≠cula intervienen varios actores.

Con el fin de afianzar el concepto de cardinalidad estudiemos una serie de ejemplos sencillos.

## Ejemplos:

- ÔÇ∑ Un m√©dico cura a un paciente 1:1
- ÔÇ∑ Un m√©dico cura a muchos pacientes 1: N

- ÔÇ∑ Una fabrica hace coches 1: N
- ÔÇ∑ Los profesores ense√±an a los alumnos N: M
- ÔÇ∑ Juan est√° casado con Mar√≠a 1:1
- ÔÇ∑ El arco iris tiene siete colores 1:N
- ÔÇ∑ Los alumnos estudian las asignaturas N: M

## Atributos asociados a una relaci√≥n

Hasta este momento se ha considerado al atributo como un √≠tem asociado a una entidad, pero es posible   que   en   algunos   casos   particulares   la   informaci√≥n   deseada   no   se   pueda   representar asign√°ndole atributos a las entidades entre las que hay establecida alguna relaci√≥n. En estos casos se opta por asociar a la relaci√≥n el atributo. Un ejemplo podr√≠a ser la representaci√≥n de la vida laboral de los trabajadores de una empresa.

Supongamos que se dispone de dos entidades, la entidad trabajador y la entidad empresa. Para representar   la   informaci√≥n   deseada   se   utiliza   la   fecha   de   alta   y   de   baja   de   cada   uno   de   los trabajadores en la citada empresa. Por lo que no ser√≠a v√°lido asignar la fecha de alta y de baja a ninguna de las entidades por separado pues la informaci√≥n que deseamos representar es la siguiente: 'dado un determinado trabajador y una empresa saber su fecha de alta y baja en la mencionada empresa'. La forma de solucionarlo es asignar esta informaci√≥n a la relaci√≥n. De este modo, dado un trabajador y una empresa se podr√° conocer tanto la fecha de incorporaci√≥n como la fecha de cese de ese trabajador en esa empresa.

## 2. Diagrama entidad-relaci√≥n

El modelo entidad-relaci√≥n aporta una herramienta de modelado para representar las entidades, relaciones y atributos: los diagramas Entidad-Relaci√≥n. Mediante √©stos, el esquema conceptual abstracto puede ser mostrado gr√°ficamente y mantener una independencia conceptual con respecto a la implementaci√≥n propiamente dicha. Este es uno de los motivos por el que este modelo es el m√°s extendido.

Existen cuatro componentes principales en el diagrama entidad-relaci√≥n:

- ÔÇ∑ Rect√°ngulos etiquetados: utilizados para representar los conjuntos de entidades.
- ÔÇ∑ Elipses etiquetadas: utilizadas para representar cada uno de los atributos que identifican a las entidades.
- ÔÇ∑ Rombos etiquetados: utilizados para representar las relaciones que unen a las

entidades.

- ÔÇ∑ L√≠neas: utilizadas para unir las entidades a las relaciones y viceversa.

Queda por tanto,   a   trav√©s   de   estas   componentes,   representada   toda   la   informaci√≥n   necesaria (entidades, relaciones y atributos).

En la pregunta anterior se explicaba que a partir del conjunto de atributos que definen a una entidad el dise√±ador de la base de datos debe elegir uno que identificar√° de forma un√≠voca a esa entidad, es decir, debe elegir una llave. Existen varias formas de representar en el diagrama entidad-relaci√≥n el atributo clave. Algunos autores se decantan por indicarlo a trav√©s de dos elipses conc√©ntricas mientras que otros lo especifican subrayando el atributo. Nosotros elegiremos esta √∫ltima opci√≥n. Otro dato que debe quedar plasmado en el diagrama entidad-relaci√≥n es la cardinalidad de la relaci√≥n.   Siendo   posible   representar   los   tres   tipos   de   cardinalidad   comentados   anteriormente. Tambi√©n para representar esta caracter√≠stica existen diferentes nomenclaturas, a continuaci√≥n se explican dos de ellas:

- ÔÇ∑ Se utilizar√° una l√≠nea dirigida es decir, una flecha,   para representar la cardinalidad N y unal√≠nea no dirigida para representar la cardinalidad varios.
- ÔÇ∑ O bien, se puede hacer uso de los valores 1:1, 1:N, N:1, N: M asociados a la  relaci√≥n.

Con el fin de darle una uniformidad al texto elegiremos una de las dos opciones, en este caso se ha optado por la segunda posibilidad.

A continuaci√≥n se va a pasar a representar a trav√©s de unos ejemplos los casos posibles a los que nos podemos enfrentar:

Diagrama entidad-relaci√≥n con cardinalidad 1:1



A trav√©s de este diagrama se representa la compra de un coche por un determinado cliente.

Diagrama entidad-relaci√≥n con cardinalidad N:1



El diagrama entidad-relaci√≥n de la figura 6.8 corresponder√≠a a la representaci√≥n de la compra de un coche por varias personas.

Si dese√°ramos representar la posibilidad de que varios clientes puedan comprar varios coches, la cardinalidad establecida en la relaci√≥n ser√≠a de N: M siendo el diagrama entidad-relaci√≥n el de la figura 6.9:

Diagrama entidad-relaci√≥n con cardinalidad N: M



La   √∫ltima   opci√≥n   posible   ser√≠a   que   un   determinado   cliente   pudiera   comprar   varios   coches informaci√≥n representada en el diagrama de la figura 6.10:

Diagrama entidad-relaci√≥n con cardinalidad 1: N



## 3. Transformaci√≥n del diagrama entidad-relaci√≥n a tablas

## 3.1. Transformaci√≥n de entidades

Cada 'tipo de entidad' se convierte en el modelo relacional en una relaci√≥n o tabla. El nombre que le demos a la misma ser√° el del tipo de entidad del cual deriva.

## 3.2. Transformaci√≥n de atributos de entidades

Cada atributo de una entidad se transforma en una columna de la relaci√≥n. En el modelo entidadrelaci√≥n distinguiremos entre AIP (Atributo Identificador Principal) o llave primaria, y el resto de atributos.

- ÔÇ∑ Cada llave primaria pasar√° a ser la clave de la tabla. √âstas evidentemente, no podr√°n tomar valores nulos.
- ÔÇ∑ El resto de atributos pasan a ser columnas de la tabla. En principio y salvo que se indique lo contrario, podr√°n tomar valores nulos. En el caso de obligatoriedad de estos atributos, lo dejaremos indicado como requerido.

## 3.3. Transformaci√≥n de relaciones

El   hecho   de   permitir   diferentes   cardinalidades   en   una   relaci√≥n   hace   tambi√©n   diferente   la transformaci√≥n de las relaciones a tablas en funci√≥n del grado que se establezca en la relaci√≥n. Existiendo los siguientes casos:

## 3.3.1. Transformaci√≥n de relaciones 1:1

Existen dos posibilidades:

- ÔÇ∑ Se crear√° una tabla que contendr√° los atributos de las dos entidades. Deber√° seleccionarse la llave primaria de una de las entidades como clave de la tabla. Normalmente elegiremos la clave de la entidad m√°s dominante.
- ÔÇ∑ Se crear√° una tabla para cada una de las entidades, una de estas tablas deber√° contener entre sus atributos la llave primaria de la otra entidad.

## 3.3.2. Transformaci√≥n de relaciones 1: n

Cuando la cardinalidad de la relaci√≥n es de 1: N la transformaci√≥n a tablas se realiza seg√∫n la siguiente regla:

La entidad de las N ocurrencias hereda la clave de la entidad de la ocurrencia √∫nica.

## 3.3.3. Transformaci√≥n de relaciones n: m

Este tipo de asociaciones requieren una tabla de la interrelaci√≥n, cuya clave ser√°, al menos, la concatenaci√≥n de las claves primarias de las entidades que asocia. Si la relaci√≥n adem√°s contuviera atributos  propios, formar√≠an obviamente, parte de la tabla que originan.

## Ejemplo:

En el a√±o 2004 las dependencias utilizadas por los empleados del departamento de investigaci√≥n y desarrollo de nuevos productos de una empresa del sector alimenticio ser√°n trasladadas a un nuevo pol√≠gono industrial. Se desea recabar informaci√≥n de forma que quede especificado el despacho en el que se ubicar√° cada empleado as√≠ como los proyectos de investigaci√≥n en los que trabajan cada uno de ellos.

Se dispone de la siguiente informaci√≥n:

- ÔÇ∑ De cada empleado se conoce su NIF, NSS, su nombre, apellidos, direcci√≥n, provincia, fecha de nacimiento, sexo, cargo que ocupa en la actualidad.
- ÔÇ∑ Cada proyecto de investigaci√≥n tiene un c√≥digo identificador y un nombre t√≠tulo del mismo, la cuant√≠a asignada, la fecha de inicio y de finalizaci√≥n del mismo. Si cuenta con subvenci√≥n p√∫blica adicional un breve resumen del mismo y el NIF del investigador principal o responsable.
- ÔÇ∑ Cada despacho tiene un n√∫mero asignado, un n√∫mero de tel√©fono, el edificio al que pertenece (Ej: Productos para farmacia) as√≠ como un c√≥digo que identifica ese edificio (Ej: PF).

Para la realizaci√≥n del ejercicio se han de tener en cuenta las siguientes restricciones:

- ÔÇ∑ Cada empleado tiene asignado un √∫nico despacho.
- ÔÇ∑ En cada despacho puede haber varios empleados.
- ÔÇ∑ En un proyecto de investigaci√≥n trabajan varios empleados permiti√©ndose que una misma persona trabaje en m√°s de un proyecto de investigaci√≥n.
- ÔÇ∑ Cada proyecto tiene un √∫nico investigador principal.

Toda base de datos debe reflejar aquella parcela del mundo real que en un momento nos interese modelizar. En este caso se pretende crear una base de datos en la que se guarde informaci√≥n relativa a los empleados que trabajan en ciertas dependencias de la empresa as√≠ como en los proyectos de investigaci√≥n en los que est√°n involucrados.

Los pasos que deben seguirse para resolver cualquier base de datos son los siguientes:

- 1.- Abstraer aquella informaci√≥n que sea relevante para el problema.
- 2.- Definidas las entidades y relaciones que participar√°n en la base de datos se deber√°n elegir los atributos llave de cada una de las entidades.
- 3.- Atendiendo a las restricciones impuestas en el ejercicio habr√° que indicar las cardinalidades para cada una de las relaciones participantes.

## Resoluci√≥n del ejercicio

La informaci√≥n descrita queda representada a trav√©s del diagrama entidad-relaci√≥n de la figura 6.11. (Pertenece, Participantes-Proyectos) que servir√°n de nexo de uni√≥n entre las entidades.

En √©l est√°n especificadas tres tipos de entidades (Empleado, Despacho, Proyecto) y dos relaciones Cada una de las entidades est√° identificada por una serie de atributos, de ellos se ha elegido la llave candidata, quedando representada en el diagrama a trav√©s del atributo subrayado.

## Entidad Empleado

Habr√≠a dos posibles llaves candidatas: N.I.F. y NSS para representar a la entidad empleado.

En este caso se ha optado por el N.I.F. Los dos atributos podr√≠an ser llaves primarias ya que son n√∫meros que servir√°n para identificar al empleado. Como se explic√≥ anteriormente, la elecci√≥n de dicha clave depender√° del dise√±ador de la base de datos, en este caso, se ha optado por la primera opci√≥n.

## Entidad Despacho

Para identificar esta entidad se ha elegido como llave primaria, el n√∫mero de despacho al ser √©ste un atributo √∫nico.

## Entidad Proyecto

La llave primaria de esta entidad ser√° el c√≥digo asignado al proyecto.

Seleccionados los atributos llaves para cada una de las entidades el siguiente paso es establecer, de acuerdo con las restricciones establecidas en el problema, las cardinalidades de las relaciones que asocian las entidades.

Figura 6.11. Diagrama entidad-relaci√≥n



Llegado a este punto, el siguiente paso para la resoluci√≥n del ejercicio consistir√° en transformar el diagrama entidad-relaci√≥n a las tablas correspondientes.

Como se observa, a la relaci√≥n Participa se le ha asociado la cardinalidad  M: N debido a que en las especificaciones del problema se dec√≠a que un determinado empleado pod√≠a participar en varios proyectos y en un determinado proyecto podr√≠an trabajar varios empleados.

En cuanto a la relaci√≥n establecida entre las entidades Empleado y Despacho la cardinalidad que se le asocia es N:1 ya que al igual que en el caso anterior, en el ejercicio se hace la puntualizaci√≥n siguiente: 'un determinado empleado tiene asignado un despacho y en un despacho pueden trabajar varios empleados'.

Siguiendo las reglas establecidas para la transformaci√≥n del diagrama entidad-relaci√≥n a tablas obtendr√≠amos las tablas siguientes:

- ÔÇ∑ Empleado ( N.I.F.-Empleado, N¬∫Despacho, NSS, Nombre, Apellidos, Direcci√≥n, Cargo, Sexo, FechaNa, Provincia)
- ÔÇ∑ Despacho ( N¬∫Despacho , Ubicaci√≥n, Tel√©fono, Edificio)
- ÔÇ∑ Proyecto (Cod-Proyecto, T√≠tulo, Cuant√≠a, Fecha Inic, Fecha Fin, Subvenci√≥n, N.I.F. Resp)
- ÔÇ∑ Participantes-Proyectos (N.I.F.-Empleado , Cod-Proyecto)

La tabla Empleado procede de la transformaci√≥n de la relaci√≥n establecida entre las entidades Empleado y Despacho. Al tener dicha relaci√≥n una cardinalidad de N: 1 la tabla Empleado estar√° formada por los atributos de la entidad de la cual deriva m√°s el atributo llave de la entidad que tiene cardinalidad m√≠nima, que en este caso es N¬∫Despacho.

De   igual   modo   surge   la   tabla   Participantes-Proyectos,   dicha   tabla   es   el   resultado   de   la transformaci√≥n de la relaci√≥n existente entre Empleado y Proyectos relaci√≥n que tiene cardinal N: M. En este caso la tabla est√° formada por la concatenaci√≥n de las llaves de las entidades que asocia.
```



## üìÑ Archivo: [Teor√≠a] Transp.Tema2.Introd.Sistemas.Operativos-PEv2.pdf

**M√©todo de extracci√≥n usado:** Docling

```markdown
## Tema 2. Introducci√≥n a los Sistemas Operativos



## 2.1 Componentes de un Sistema Operativo (SO) multiprogramado.

- 2.1.1 Sistemas multiprogramados y de tiempo compartido.
- 2.1.2 Concepto de proceso.
- 2.1.3 Modelo de cinco estados de los procesos.

## 2.2 Descripci√≥n y control de procesos.

- 2.2.1 Bloque de control de proceso (PCB).
- 2.2.2 Control de procesos.
- 2.3 Hebras (hilos).
- 2.4 Gesti√≥n b√°sica de memoria.
- 2.4.1 Paginaci√≥n
- 2.4.2 Segmentaci√≥n

## Bibliograf√≠a b√°sica

[Stal05]

W. Stallings, Sistemas Operativos, Aspectos Internos y Principios de Dise√±o (5¬™ Edici√≥n) . Pearson Education, 2005

[Carr07]

- J. Carretero, F. Garc√≠a, P. de Miguel, F. P√©rez, Sistemas Operativos (2¬™ Edici√≥n) , McGraw-Hill, 2007

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

LENGUAJES Y SISTEMAS INFORM√ÅTICOS

14-Oct-2016

Fundamentos del Software

1er Curso del Doble Grado en Ingenier√≠a Inform√°tica y ADE



- ¬∑ Conocer los elementos necesarios para implementar la multiprogramaci√≥n en un sistema operativo (SO).
- ¬∑ Conocer el concepto de proceso y el modelo de cinco estados de los procesos.
- ¬∑ Conocer el uso que realiza el SO del apoyo hardware e integrarlo en el modelo de cinco estados.
- ¬∑ Conocer el concepto de hebra (hilo), su modelo de cinco estados y su utilidad.
- ¬∑ Conocer la gesti√≥n b√°sica de memoria que realiza el SO.

1

## 2.1 Componentes de un SO multiprogramado

Tema 2. Introducci√≥n a los Sistemas Operativos

## 2.1.1 Concepto de multiprogramaci√≥n [Stall05] (pp. 58-67)

## Procesamiento en Serie:

Manejadores de dispositivo

- ¬∑ El programador interact√∫a directamente con la m√°quina, no existe S.O.
- ¬∑ Problemas: Baja utilizaci√≥n del tiempo de CPU, Tiempo de planificaci√≥n alto.

## Sistemas por lotes (Sistemas Batch):

- ¬∑ Agrupa trabajos similares: reduce el tiempo de planificaci√≥n.
- ¬∑ Trabajo = (programa + datos + ordenes de control para el sistema)
- ¬∑ Falta de interacci√≥n entre el usuario y el computador mientras se ejecuta su trabajo.
- ¬∑ Principal problema: CPU ociosa durante las E/S. Soluci√≥n: Spooling: Superpone la E/S de un trabajo al c√≥mputo de otros.

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

Cargador

Secuenciador de trabajos

Int√©rprete de tarjetas de control

√Årea para el programa de usuario

- ¬∑ Control inicial en el Monitor
- ¬∑ Transferencia del control al trabajo
- ¬∑ Al finalizar el trabajo, el control vuelve al monitor

2

Monitor residente

## 2.1 Componentes de un SO multiprogramado

## 2.1.1 Concepto de multiprogramaci√≥n

Program A

Run

Wait

Time

Run

Wait Run

Wait

Program A

Program B

Program ‚Ç¨

Combined

Run

Run

A

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

LENGUAJES Y SISTEMAS INFORM√ÅTICOS

B

Run

(a) Uniprogramming

Wait

Run

Wait

Run

Run

Wait

Wait

Run

A

Run

Run

B

Time

- (c Multiprogramming with three programs

Fundamentos del Software

Tema 2. Introducci√≥n a los Sistemas Operativos

Wait

Wait

Wait

Run

Run

Wait

Wait

## 2.1 Componentes de un SO multiprogramado

## 2.1.1 Concepto de multiprogramaci√≥n

|                      | Trabajo 1          | Trabajo 2            | Trabajo 3            |
|----------------------|--------------------|----------------------|----------------------|
| Tipo de trabajo      | Computaci√≥n pesada | Gran cantidad de E/S | Gran cantidad de E/S |
| Duraci√≥n             | 5 minutos          | 15 minutos           | 10 minutos           |
| Memoria requerida    | 50 MB              | 100 MB               | 75 MB                |
| ¬øNecesita disco?     | NO                 | NO                   | SI                   |
| ¬øNecesita terminal?  | NO                 | SI                   | NO                   |
| ¬øNecesita impresora? | NO                 | NO                   | SI                   |

- ¬∑ Trabajo1 utiliza mucho la CPU, Trabajo2 y Trabajo3 utilizan mucho los perif√©ricos de E/S.

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

4

## 2.1 Componentes de un SO multiprogramado

Tema 2. Introducci√≥n a los Sistemas Operativos



## 2.1 Componentes de un SO multiprogramado

Tema 2. Introducci√≥n a los Sistemas Operativos

## Ejemplo de multiprogramaci√≥n

| Monoprogramaci√≥n   |                  | Multiprogramaci√≥n         |
|--------------------|------------------|---------------------------|
| 20%                | 40%              | Uso del procesador        |
| 33%                | 67%              | Uso de memoria            |
| 33%                | 67%              | Uso de disco              |
| 33%                | 67%              | Uso de impresora          |
| 30 minutos         | 15 minutos       | Tiempo transcurrido       |
| 6 trabajos/hora    | 12 trabajos/hora | Productividad             |
| 18 minutos         | 10 minutos       | Tiempo de respuesta medio |

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

6

## 2.1 Componentes de un SO multiprogramado

Tema 2. Introducci√≥n a los Sistemas Operativos

## Definiciones

- S.O. multiprogramado: S.O. que permite que se ejecute m√°s de un proceso simut√°neamente y cuyos datos e instrucciones se encuentran en memoria principal.
- S.O. monousuario: Proporciona servicios a un √∫nico usuario.
- S.O. multiusuario: Proporciona servicios a varios usuarios simult√°neamente.
- S.O. monoprocesador: S.O. que gestiona un sistema de computaci√≥n de un √∫nico procesador.
- S.O. multiprocesador: S.O. que gestiona un sistema de computaci√≥n de varios procesadores.
- S.O. de tiempo compartido: S.O. multiprogramado donde se realiza un reparto de tiempo del procesador en peque√±os trozos de tal forma que todos los procesos pueden avanzar adecuadamente. Especialmente dise√±ado para sistemas interactivos.

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

7

## 2.1 Componentes de un SO multiprogramado

Fundamentos del Software

Tema 2. Introducci√≥n a los Sistemas Operativos

Algunas cuestiones interesantes ‚Ä¶

- ÔÅ± ¬øUn S.O. multiprogramado es un S.O. de tiempo compartido? ¬øy al contrario?
- ÔÅ± ¬øUn S.O. de tiempo compartido tiene que ser multiusuario? ¬øy monousuario?
- ÔÅ± ¬øUn S.O. monoprocesador tiene que ser monousuario? ¬øy multiusuario?
- ÔÅ± ¬øUn S.O. multiprocesador tiene que ser monousuario? ¬øy multiusuario?

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

LENGUAJES Y SISTEMAS INFORM√ÅTICOS

8

## 2.1 Componentes de un SO multiprogramado

- 2.1.2 Concepto de proceso [Stal05] (pp. 68-71)
- ¬∑ Un programa en ejecuci√≥n.
- ¬∑ Una instancia de un programa ejecut√°ndose en un ordenador.
- ¬∑ La entidad que se puede asignar o ejecutar en un procesador.
- ¬∑ Una unidad de actividad caracterizada por un solo flujo de ejecuci√≥n , un estado actual y un conjunto de recursos del sistema asociados.
- ¬∑ Un proceso est√° formado por:
- ÔÅ± Un programa ejecutable .
- ÔÅ± Datos que necesita el SO para ejecutar el programa .

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

Tema 2. Introducci√≥n a los Sistemas Operativos

## 2.1 Componentes de un SO multiprogramado

Tema 2. Introducci√≥n a los Sistemas Operativos

Bloque de Control de Proceso (PCB, Process Control Block) [Stal05] (pp. 108-114)

Identificador

Estado

Prioridad

Contador de programa

Punteros de memoria

Datos de contexto

Informaci√≥n de estado de E/S

Informaci√≥n de auditor√≠a

¬∑

¬∑

¬∑

- ¬∑ Identificador de proceso , (PID, del ingl√©s Process IDentificator).
- ¬∑ Contexto de ejecuci√≥n : Contenido de los registros del procesador.
- ¬∑ Memoria donde reside el programa y sus datos.
- ¬∑ Informaci√≥n relacionada con recursos del sistema.
- ¬∑ Estado: En que situaci√≥n se encuentra el proceso en cada momento (modelo de estados).
- ¬∑ Otra informaci√≥n.

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

## 2.1 Componentes de un SO multiprogramado

Fundamentos del Software

Tema 2. Introducci√≥n a los Sistemas Operativos

## Implementaci√≥n de Procesos T√≠pica [Stal05] (Fig. 2.8, p. 70)

- ¬∑ Esta implementaci√≥n permite ver al proceso como una estructura de datos .
- ¬∑ El estado completo del proceso en un instante dado se almacena en su PCB ( Context en la figura).
- ¬∑ Esta estructura permite el desarrollo de t√©cnicas potentes que aseguren la coordinaci√≥n y la cooperaci√≥n entre los procesos .

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

LENGUAJES Y SISTEMAS INFORM√ÅTICOS



## 2.1 Componentes de un SO multiprogramado

Tema 2. Introducci√≥n a los Sistemas Operativos

## Concepto de traza de ejecuci√≥n

- ¬∑ Una traza de ejecuci√≥n es un listado de la secuencia de las instrucciones de un programa que realiza el procesador para un proceso.
- ¬∑ Desde el punto de vista del procesador se entremezclan las trazas de ejecuci√≥n de los procesos y las trazas del c√≥digo del SO.

¬øEn qu√© situaciones se pueden entremezclar las trazas de los procesos y las trazas del c√≥digo del SO?

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

12

## 2.1 Componentes de un SO multiprogramado

## Ejemplo de traza de ejecuci√≥n

Main Memory

Process B

Process ‚Ç¨

12000

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

LENGUAJES Y SISTEMAS INFORM√ÅTICOS

Tema 2. Introducci√≥n a los Sistemas Operativos

Dispatcher: M√≥dulo del SO que se encarga de realizar el intercambio de procesos en el procesador.

## 2.1 Componentes de un SO multiprogramado

5001

## Ejemplo de traza de ejecuci√≥n

|   5000 | 8000   |   12000 |
|--------|--------|---------|
|   5001 | 8001   |   12001 |
|   5002 | 8002   |   12002 |
|   5003 | 8003   |   12003 |
|   5004 |        |   12004 |
|   5005 |        |   12005 |
|   5006 |        |   12006 |
|   5007 |        |   12007 |
|   5008 |        |   12008 |
|   5009 |        |   12009 |
|   5010 |        |   12010 |
|   5011 |        |   12011 |

(a Trace of Process A (b) Trace of Process B (c Trace of Process

5000 = Starting address of program of Process A

12000 = Starting address of program of Process ‚Ç¨

8000 = Starting address of program of Process B

## 100 = Starting address of dispatcher program

Shaded areas indicate execution of dispatcher process:

first and third colunns count instruction cycles:

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

LENGUAJES Y SISTEMAS INFORM√ÅTICOS

3

4

5

6

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

5002

5003

5004

5005

100

101

102

103

104

105

8000

8001

8002

8003

100

101

102

103

104

105

12000

12001

12002

12003

being

Timeout

IO Request

## Fundamentos del Software

Tema 2. Introducci√≥n a los Sistemas Operativos

27

12004

28

29

30

31

32

33

34

35

36

37

38

39

40

41

42

43

44

45

46

47

48

49

50

51

52

12005

100

101

102

103

104

105

5006

5007

5008

5009

5010

5011

100

101

102

103

104

105

12006

12007

12008

12009

12010

12011

Timeout

Timeout

Timeout

14

## 2.1 Componentes de un SO multiprogramado

Tema 2. Introducci√≥n a los Sistemas Operativos

Llamadas al Sistema [Carr07] (pp. 114-115)

- ¬∑ Es la forma en la que se comunican los programas de usuario con el SO en tiempo de ejecuci√≥n.
- ¬∑ Son peticiones de servicio que se hace el proceso al SO.
- ¬∑ Ejemplos de llamadas al sistema:
- ÔÉò Solicitudes de E/S.
- ÔÉò Gesti√≥n de procesos.
- ÔÉò Gesti√≥n de memoria.
- ¬∑ Se implementan a trav√©s de una trampa ( trap ) o 'interrupci√≥n software'.

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

15

## 2.1 Componentes de un SO multiprogramado

Tema 2. Introducci√≥n a los Sistemas Operativos

Pasos realizados durante una llamada al Sistema



## 2.1 Componentes de un SO multiprogramado

Tema 2. Introducci√≥n a los Sistemas Operativos

- 2.1.3 Modelo de cinco estados de los procesos [Stal05] (pp. 114-120)
- ¬∑ El modelo de cinco estados trata de representar las actividades que el SO lleva a cabo sobre los procesos:
- ÔÇß Creaci√≥n.
- ÔÇß Terminaci√≥n.
- ÔÇß Multiprogramaci√≥n.
- ¬∑ Para ello hace uso de cinco estados:

ÔÅ± Nuevo

ÔÅ± Preparado (listo para ejecutarse)

ÔÅ± Ejecut√°ndose

ÔÅ± Bloqueado

ÔÅ± Finalizado

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

17

## 2.1 Componentes de un SO multiprogramado

Fundamentos del Software

Tema 2. Introducci√≥n a los Sistemas Operativos

## 2.1.3 Modelo de cinco estados de los procesos



LENGUAJES Y SISTEMAS INFORM√ÅTICOS

## 2.1 Componentes de un SO multiprogramado

Tema 2. Introducci√≥n a los Sistemas Operativos

## Transiciones entre estados

- ¬∑ Nuevo ‚Üí Preparado . El PCB est√° creado y el programa est√° disponible en memoria.
- ¬∑ Ejecut√°ndose ‚Üí Finalizado . El proceso finaliza normalmente o es abortado por el SO a causa de un error no recuperable.
- ¬∑ Preparado ‚Üí Ejecut√°ndose . El SO (planificador CPU) selecciona un proceso para que se ejecute en el procesador.
- ¬∑ Ejecut√°ndose ‚Üí Bloqueado . El proceso solicita algo al SO por lo que debe esperar.
- ¬∑ Ejecut√°ndose ‚Üí Preparado . Un proceso ha alcanzado el m√°ximo tiempo de ejecuci√≥n ininterrumpida.
- ¬∑ Bloqueado ‚Üí Preparado . Se produce el evento por el cual el SO bloque√≥ al proceso.

Preparado (o Bloqueado) ‚Üí Finalizado . Terminaci√≥n de un proceso por parte de otro (en la mayor√≠a de los SO modernos, no se permite).

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

## 2.2 Descripci√≥n y control de procesos

## 2.2.1  Descripci√≥n de procesos: PCB [Carr07] (p. 87)

- ¬∑ Identificadores : Del proceso, del padre del proceso, del usuario, ‚Ä¶
- ¬∑ Contexto de ejecuci√≥n : valores de los registros PC PSW SP , , , ‚Ä¶
- ¬∑ Informaci√≥n para control del proceso :
- ¬∑ Informaci√≥n de estado y planificaci√≥n.
- ¬∑ Descripci√≥n de las regiones de memoria asignadas .
- ¬∑ Recursos asignados.
- ¬∑ Enlaces a colas de procesos.
- ¬∑ Comunicaci√≥n entre procesos.

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

## 2.2 Descripci√≥n y control de procesos

Tema 2. Introducci√≥n a los Sistemas Operativos

Creaci√≥n de un proceso: Inicializaci√≥n de PCB [Stal05] (p. 137)

- ¬∑ Asignar identificador √∫nico al proceso.
- ¬∑ Asignar un nuevo PCB.
- ¬∑ Asignar memoria para el programa asociado.
- ¬∑ Inicializar PCB :
- ¬∑ PC : Direcci√≥n inicial de comienzo del programa.
- ¬∑ SP : Direcci√≥n de la pila de sistema.
- ¬∑ Memoria donde reside el programa.
- ¬∑ El resto de campos se inicializan a valores por omisi√≥n.

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

21

- 2.2 Descripci√≥n y control de procesos
- 2.2.2  Control de procesos: modos de ejecuci√≥n del procesador  [Carr07] (p. 4)
- ¬∑ Modo usuario . El programa (de usuario) que se ejecuta en este modo s√≥lo se tiene acceso a:
- ÔÇß Un subconjunto de los registros del procesador.
- ÔÇß Un subconjunto del repertorio de instrucciones m√°quina.
- ÔÇß Un √°rea de la memoria.
- ¬∑ Modo n√∫cleo (kernel o supervisor o sistema). El programa (SO) que se ejecuta en este modo tiene acceso a todos los recursos de la m√°quina, tanto software como hardware.

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

## 2.2 Descripci√≥n y control de procesos

Tema 2. Introducci√≥n a los Sistemas Operativos

## ¬øC√≥mo utiliza el SO el modo de ejecuci√≥n?

- ¬∑ El modo de ejecuci√≥n (incluido en PSW) cambia a modo kernel, autom√°ticamente por hardware, cuando se produce:
- ÔÇß Una interrupci√≥n.
- ÔÇß Una excepci√≥n.
- ÔÇß Una llamada al sistema.
- ¬∑ Seguidamente se ejecuta la rutina del SO correspondiente al evento producido.
- ¬∑ Finalmente, cuando termina la rutina, el hardware restaura autom√°ticamente el modo de ejecuci√≥n a modo usuario.

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

## 2.2 Descripci√≥n y control de procesos

Tema 2. Introducci√≥n a los Sistemas Operativos

Control de procesos: operaci√≥n de cambio de modo [Stal05] (pp. 139-140)

- ¬∑ Se ejecuta una rutina del SO en el contexto del proceso que se encuentra en estado ' Ejecut√°ndose '.
- ¬∑ ¬øCu√°ndo puede realizarse? Siempre que el SO pueda ejecutarse, luego solamente como resultado de:
- ÔÇß Una interrupci√≥n.
- ÔÇß Una excepci√≥n.
- ÔÇß Una llamada al sistema.

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

## 2.2 Descripci√≥n y control de procesos

Tema 2. Introducci√≥n a los Sistemas Operativos

## Pasos en la operaci√≥n de cambio de modo

- 1) El hardware autom√°ticamente salva como m√≠nimo el PC y PSW y cambia el bit de modo a modo kernel .
- 2) Determinar autom√°ticamente la rutina del SO que debe ejecutarse y cargar el PC con su direcci√≥n de comienzo.
- 3) Ejecutar la rutina . Posiblemente la rutina comience salvando el resto de registros del procesador y termine restaurando en el procesador la informaci√≥n de registros previamente salvada .
- 4) Volver de la rutina del SO al proceso que se estaba ejecutando. El hardware autom√°ticamente restaura en el procesador la informaci√≥n del PC y PSW previamente salvada .

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

## 2.2 Descripci√≥n y control de procesos

Control de procesos: operaci√≥n de cambio de contexto (cambio de proceso) [Stal05] (pp. 138-139)

- ¬∑ Un proceso en estado ' Ejecut√°ndose ' cambia a otro estado y un proceso en estado ' Preparado ' pasa a estado ' Ejecut√°ndose '.
- ¬∑ ¬øCu√°ndo puede realizarse? Cuando el SO pueda ejecutarse y decida llevarlo a cabo. Luego solamente como resultado de:
- ÔÇß Una interrupci√≥n.
- ÔÇß Una excepci√≥n.
- ÔÇß Una llamada al sistema.

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

- 2.2 Descripci√≥n y control de procesos

Pasos en una operaci√≥n de cambio de contexto (Dispatcher)

- 1) Salvar los registros del procesador en el PCB del proceso que actualmente est√° en estado ' Ejecut√°ndose '.
- 2) Actualizar el campo estado del proceso al nuevo estado al que pasa e insertar el PCB en la cola correspondiente.
- 3) S eleccionar un nuevo proceso del conjunto de los que se encuentran en estado ' Preparado ' ( Scheduler o Planificador de CPU).
- 4) Actualizar el estado del proceso seleccionado a ' Ejecut√°ndose ' y sacarlo de la cola de preparados.
- 5) Cargar los registros del procesador con la informaci√≥n de los registros almacenada en el PCB del proceso seleccionado.
- ¬øSi se produce una interrupci√≥n, una excepci√≥n o una llamada al sistema, se produce necesariamente un cambio de modo ? ¬øy un cambio de contexto ?

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

27

## 2.3 Hebras (hilos)

## 2.3 Concepto de Hebra [Stal05] (pp. 158-161)

- ¬∑ El concepto de proceso ( tarea ) tiene dos caracter√≠sticas diferenciadas que permiten al SO:
- ¬∑ Controlar la asignaci√≥n de los recursos necesarios para la ejecuci√≥n de programas.
- ¬∑ La ejecuci√≥n del programa asociado al proceso de forma intercalada con otros programas.
- ¬∑ El concepto de proceso ( tarea ) y hebras asociadas se basa en separar estas dos caracter√≠sticas:
- ¬∑ La tarea se encarga de soportar todos los recursos necesarios (incluida la memoria ).
- ¬∑ Cada una de las hebras permite la ejecuci√≥n del programa de forma ' independiente ' del resto de hebras .

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

## 2.3 Hebras (hilos)

## Concepto de Hebra



Figure 4.2 Single Threaded and Multithreaded Process Models



DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

Tema 2. Introducci√≥n a los Sistemas Operativos

## 2.3 Hebras (hilos)

## Modelo de cinco estados para hebras

- ¬∑ Las hebras debido a su caracter√≠stica de ejecuci√≥n de programas presentan cinco estados an√°logos al modelo de estados para procesos:
- ¬∑ Ejecut√°ndose
- ¬∑ Preparado (listo para ejecutarse)
- ¬∑ Bloqueado
- ¬∑ Nuevo
- ¬∑ Finalizado



DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

LENGUAJES Y SISTEMAS INFORM√ÅTICOS

2.3 Hebras (hilos)

Ventajas de las hebras [Stal05] (p. 163)

I/O

Request request

complete

Time quantum expires

Thread

A (Process 1)

Thread B (Process 1)

Thread ‚Ç¨ (Process 2)

Blocked

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

LENGUAJES Y SISTEMAS INFORM√ÅTICOS

Process created

Ready

Fundamentos del Software

Tema 2. Introducci√≥n a los Sistemas Operativos

Time quantum expires

Running

31

## 2.3 Hebras (hilos)

## Ventajas de las hebras [Stal05] (pp. 160-165)

- ¬∑ Menor tiempo de creaci√≥n de una hebra en un proceso ya creado que la creaci√≥n de un nuevo proceso.
- ¬∑ Menor tiempo de finalizaci√≥n de una hebra que de un proceso.
- ¬∑ Menor tiempo de cambio de contexto ( hebra ) entre hebras pertenecientes al mismo proceso.
- ¬∑ Facilitan la comunicaci√≥n entre hebras pertenecientes al mismo proceso.
- Single-Threaded Multithreaded ¬∑ Permiten aprovechar las t√©cnicas de programaci√≥n concurrente y el multiprocesamiento sim√©trico .



DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_



LENGUAJES Y SISTEMAS INFORM√ÅTICOS

## 2.4 Gesti√≥n b√°sica de memoria

- 2.4 Carga absoluta y reubicaci√≥n [Stall05] (pp. 308-309, 331-337)
- ¬∑ Carga absoluta. Asignar direcciones f√≠sicas (direcciones de memoria principal) al programa en tiempo de compilaci√≥n. El programa no es reubicable.
- ¬∑ Reubicaci√≥n . Capacidad de cargar y ejecutar un programa en un lugar arbitrario de la memoria.

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

## 2.4 Gesti√≥n b√°sica de memoria

## Carga absoluta

Programa Fuente

Compilador

(y Encuadernador)

X

Programa

N

Ejecutable direcciones absolutas

Memoria Principal

S.O.

Cargador

X

N

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

LENGUAJES Y SISTEMAS INFORM√ÅTICOS

Y

Y+M

Fundamentos del Software

Tema 2. Introducci√≥n a los Sistemas Operativos

## Reubicaci√≥n

Programa Fuente

Compilador

(y Encuadernador)

0

Programa

M

Ejecutable direcciones l√≥gicas o relativas

Memoria Principal

S.O.

Cargador

O

Hardware

34

## 2.4 Gesti√≥n b√°sica de memoria

Tema 2. Introducci√≥n a los Sistemas Operativos

## Reubicaci√≥n est√°tica

- ¬∑ El compilador genera direcciones l√≥gicas (relativas) de 0 a M.
- ¬∑ La decisi√≥n de d√≥nde ubicar el programa en memoria principal se realiza en tiempo de carga .
- ¬∑ El cargador a√±ade la direcci√≥n base de carga a todas las referencias relativas a memoria del programa .

1000

Programa ejecutable con direcciones l√≥gicas

0

MOVE A, 100

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

LENGUAJES Y SISTEMAS INFORM√ÅTICOS

M

MOVE A, 1100

1000 + M

Memoria Principal

35

## 2.4 Gesti√≥n b√°sica de memoria

## Reubicaci√≥n din√°mica

- ¬∑ El compilador genera direcciones l√≥gicas (relativas) de 0 a M.
- ¬∑ La traducci√≥n de direcciones l√≥gicas a f√≠sicas se realiza en tiempo de ejecuci√≥n luego el programa est√° cargado con referencias relativas.
- ¬∑ Requiere apoyo hardware .

b

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

LENGUAJES Y SISTEMAS INFORM√ÅTICOS

R.Base

b

CPU

+

Direcci√≥n

L√≥gica

Direcci√≥n

F√≠sica

Hardware

MOVE A, 100

b + M

Memoria Principal

## 2.4 Gesti√≥n b√°sica de memoria

Tema 2. Introducci√≥n a los Sistemas Operativos

## Espacios para las direcciones de memoria

- ¬∑ Espacio de direcciones l√≥gico. Conjunto de direcciones l√≥gicas (o relativas) que utiliza un programa ejecutable.
- ¬∑ Espacio de direcciones f√≠sico. Conjunto de  direcciones f√≠sicas (memoria principal) correspondientes a las direcciones l√≥gicas del programa en un instante dado.
- ¬∑ Mapa de memoria de un ordenador . Todo el espacio de memoria direccionable por el ordenador. Normalmente depende del tama√±o del bus de direcciones.
- ¬∑ Mapa de memoria de un proceso . Se almacena en una estructura de datos (que reside en memoria) donde se guarda el tama√±o total del espacio de direcciones l√≥gico y la correspondencia entre las direcciones l√≥gicas y las f√≠sicas.

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

37

## 2.4 Gesti√≥n b√°sica de memoria

## Ejemplo de mapa de memoria de un proceso [Carr07] (p. 277)

Pablo

Cerezo S√°nchez

√Ålvaro Alejandro De Rada   ero Ejecutable

Eduardo Mu√±oz Del Pin ontador de programa inicial



DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

LENGUAJES Y SISTEMAS INFORM√ÅTICOS

## 2.4 Gesti√≥n b√°sica de memoria

## Problema de la fragmentaci√≥n de memoria [Stal05] (pp. 314-316)

SO

148 k

SO

148 k

SO

148 k

SO

Proceso 1

SO

Proceso 1

Proceso 4

Proceso 3

320 k

576 k

148 k

320 k

128 k

96 k

268 k

64 k

Proceso 1

Proceso 2

SO

Proceso 4

Proceso 3

320 k

224 k

352 k

148 k

320 k

128 k

96 k

268 k

64 k

Proceso 1

Proceso 2

Proceso 3

SO

Proceso 5

Proceso 4

Proceso 3

SO

Proceso 1

Proceso 3

896 k

148 k

320 k

224 k

268 k

64 k

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

LENGUAJES Y SISTEMAS INFORM√ÅTICOS

128 k

320 k

224 k

268 k

84 k

148 k

230 k

90 k

128 k

96 k

268 k

64 k

## 2.4 Gesti√≥n b√°sica de memoria

Soluci√≥n a la fragmentaci√≥n de memoria [Stall05] (pp. 321-327)

- ¬∑ Trocear el espacio l√≥gico en unidades m√°s peque√±as: p√°ginas (elementos de longitud fija), o segmentos (elementos de longitud variable).
- ¬∑ Los trozos no tienen por qu√© ubicarse consecutivamente en el espacio f√≠sico.
- ¬∑ Los esquemas de organizaci√≥n del espacio l√≥gico de direcciones y de traducci√≥n de una direcci√≥n del espacio l√≥gico al espacio f√≠sico que comentaremos son:
- ÔÅ± Paginaci√≥n
- ÔÅ± Segmentaci√≥n

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

## 2.4 Gesti√≥n b√°sica de memoria

Tema 2. Introducci√≥n a los Sistemas Operativos

## 2.4.1 Paginaci√≥n

- ¬∑ El espacio de direcciones f√≠sicas de un proceso puede ser no contiguo.
- ¬∑ La memoria f√≠sica se divide en bloques de tama√±o fijo, denominados marcos de p√°gina . El tama√±o es potencia de dos, de 512 B a 8 KB.
- ¬∑ El espacio l√≥gico de un proceso se divide conceptualmente en bloques del mismo tama√±o, denominados p√°ginas.
- ¬∑ Los marcos de p√°gina contendr√°n p√°ginas de los procesos.

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

## 2.4 Gesti√≥n b√°sica de memoria

Tema 2. Introducci√≥n a los Sistemas Operativos

## 2.4.1 Paginaci√≥n

Las direcciones l√≥gicas , que son las que genera la CPU, se dividen en n√∫mero de p√°gina (p) y desplazamiento dentro de la p√°gina (d).



Las direcciones f√≠sicas se dividen en n√∫mero de marco (m, marco donde est√° almacenada la p√°gina) y desplazamiento (d).

m

d

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

LENGUAJES Y SISTEMAS INFORM√ÅTICOS

42

## 2.4 Gesti√≥n b√°sica de memoria

## 2.4.1 Paginaci√≥n

Cuando la CPU genere una direcci√≥n l√≥gica ser√° necesario traducirla a la direcci√≥n f√≠sica correspondiente, la tabla de p√°ginas mantiene informaci√≥n necesaria para realizar dicha traducci√≥n. Existe una tabla de p√°ginas por proceso.

Tabla de marcos de p√°gina, usada por el S.O. y contiene informaci√≥n sobre cada marco de p√°gina.

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

## 2.4 Gesti√≥n b√°sica de memoria

## Contenido de la tabla de p√°ginas

Una entrada por cada p√°gina del proceso:

- ¬∑ N√∫mero de marco en el que est√° almacenada la p√°gina si est√° en MP.
- ¬∑ Modo de acceso autorizado a la p√°gina (bits de protecci√≥n).

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

Fundamentos del Software

Tema 2. Introducci√≥n a los Sistemas Operativos

## 2.4 Gesti√≥n b√°sica de memoria

Fundamentos del Software

Tema 2. Introducci√≥n a los Sistemas Operativos

## Esquema de traducci√≥n



Direcci√≥n f√≠sica = m * tama√±o\_p√°gina + Desplazamiento

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

LENGUAJES Y SISTEMAS INFORM√ÅTICOS

45

## 2.4 Gesti√≥n b√°sica de memoria

Tema 2. Introducci√≥n a los Sistemas Operativos

Implementaci√≥n de la Tabla de P√°ginas

- ¬∑ La tabla de p√°ginas se mantiene en memoria principal.
- ¬∑ El registro base de la tabla de p√°ginas ( RBTP ) apunta a la tabla de p√°ginas (suele almacenarse en el PCB del proceso).
- ¬∑ En este este esquema cada acceso a una instrucci√≥n o dato requiere dos accesos a memoria , uno a la tabla de p√°ginas y otro a memoria.

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

## 2.4 Gesti√≥n b√°sica de memoria

B√∫fer de Traducci√≥n Adelantada (TLB) [Stal05] (pp. 349-351)

- ¬∑ El problema de los dos accesos a memoria se resuelve con una cach√© hardware de consulta r√°pida denominada b√∫fer de traducci√≥n adelantada o TLB Translation Look-aside Buffer ( ).
- ¬∑ El TLB se implementa como un conjunto de registros asociativos que permiten una b√∫squeda en paralelo.
- ¬∑ De esta forma, para traducir una direcci√≥n:
- 1 Si existe ya en el registro asociativo, obtenemos el marco.
- 2 Si no, la buscamos en la tabla de p√°ginas y se actualiza el TLB con esta nueva entrada.

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

47

## 2.4 Gesti√≥n b√°sica de memoria

Fundamentos del Software

Tema 2. Introducci√≥n a los Sistemas Operativos

## Esquema de traducci√≥n con TLB



DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

LENGUAJES Y SISTEMAS INFORM√ÅTICOS

## 2.4 Gesti√≥n b√°sica de memoria

Tema 2. Introducci√≥n a los Sistemas Operativos

## 2.4.2 Segmentaci√≥n

Esquema de organizaci√≥n de memoria que soporta mejor la visi√≥n de memoria del usuario: un programa es una colecci√≥n de unidades l√≥gicas -segmentos-, p. ej. procedimientos, funciones, pila, tabla de s√≠mbolos, matrices, etc.



## 2.4 Gesti√≥n b√°sica de memoria

## Tabla de Segmentos

Una direcci√≥n l√≥gica es una tupla:

&lt;n√∫mero\_de\_segmento, desplazamiento&gt;

- La Tabla de Segmentos aplica direcciones bidimensionales definidas por el usuario en direcciones f√≠sicas de una dimensi√≥n. Cada entrada de la tabla tiene los siguientes elementos (aparte de presencia, modificaci√≥n y protecci√≥n):
- ¬ª base - direcci√≥n f√≠sica donde reside el inicio del segmento en memoria.
- ¬ª tama√±o - longitud del segmento.

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

Tema 2. Introducci√≥n a los Sistemas Operativos

## 2.4 Gesti√≥n b√°sica de memoria

## Implementaci√≥n de la Tabla de Segmentos

- ¬∑ La tabla de segmentos se mantiene en memoria principal.
- ¬∑ El Registro Base de la Tabla de Segmentos ( RBTS ) apunta a la tabla de segmentos (suele almacenarse en el PCB del proceso).
- ¬∑ El Registro Longitud de la Tabla de Segmentos ( STLR ) indica el n√∫mero de segmentos del proceso; el n¬∫ de segmento s, generado en una direcci√≥n l√≥gica, es legal si s &lt; STLR (suele almacenarse en el PCB del proceso).

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

51

2.4 Gesti√≥n b√°sica de memoria

Fundamentos del Software

Tema 2. Introducci√≥n a los Sistemas Operativos

## Esquema de traducci√≥n



DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

LENGUAJES Y SISTEMAS INFORM√ÅTICOS

52
```



## üìÑ Archivo: [Teor√≠a] Transp.Tema3.Compilacion.y.Enlazado.pdf

**M√©todo de extracci√≥n usado:** Docling

```markdown
1er Curso del Doble Grado en Ingenier√≠a Inform√°tica y ADE

## Tema 3. Compilaci√≥n y Enlazado de Programas



- 3.1 Lenguajes de Programaci√≥n.
- 3.2 Construcci√≥n de Traductores.
- 3.3 Proceso de Compilaci√≥n.
- 3.3.1 An√°lisis L√©xico.
- 3.3.2 An√°lisis Sint√°ctico.
- 3.3.3 An√°lisis Sem√°ntico.
- 3.3.4 Generaci√≥n y Optimizaci√≥n de C√≥digo.
- 3.4 Int√©rpretes.
- 3.5 Modelos de Memoria de un Proceso.
- 3.6 Ciclo de Vida de un Programa.
- 3.7 Bibliotecas.
- 3.8 Automatizaci√≥n del Proceso de Compilaci√≥n y Enlazado.



[Prie06]

A. Prieto, A. Lloris, J.C. Torres, Introducci√≥n a la Inform√°tica (4¬™ Edici√≥n) , McGraw-Hill, 2006

[Carr07]

J. Carretero, F. Garc√≠a, P. de Miguel, F. P√©rez, Sistemas Operativos (2¬™ Edici√≥n) , McGraw-Hill, 2007

[Aho08]

A.V. Aho, M.S. Lam, R. Sethi, J.D. Ullman, Compiladores. Principios, T√©cnicas y Herramientas (2¬™ Edici√≥n) . Addison Wesley, 2008.

Bibliograf√≠a b√°sica



- ¬∑ Justificar la existencia de los lenguajes de programaci√≥n.
- ¬∑ Conocer el proceso de traducci√≥n.
- ¬∑ Diferenciar entre compilaci√≥n e interpretaci√≥n.
- ¬∑ Identificar los elementos que intervienen en la gesti√≥n de memoria.
- ¬∑ Conocer las necesidades de memoria de los procesos.
- ¬∑ Conocer el proceso de enlazado de programas.
- ¬∑ Conocer las diferencias entre enlace est√°tico y din√°mico.
- ¬∑ Reconocer diferentes tipos de bibliotecas.

## 3.1 Lenguajes de Programaci√≥n

## Concepto de Lenguaje de Programaci√≥n [Prie06] (pp. 581-591)

Lenguaje de programaci√≥n es un conjunto de s√≠mbolos y de reglas para combinarlos, que se usan para expresar algoritmos.

## Caracter√≠sticas:

- ¬∑ Son independientes de la arquitectura f√≠sica del computador, lo que aumenta la portabilidad de los programas.
- ¬∑ Una instrucci√≥n en un lenguaje de alto nivel da lugar, tras el proceso de traducci√≥n, a varias instrucciones en lenguaje m√°quina.
- ¬∑ Un lenguaje de alto nivel utiliza notaciones f√°cilmente reconocibles por las personas en el √°mbito en que se usan.

| A Ito Nivel   |        |
|---------------|--------|
|               | 021404 |

## 3.2 Construcci√≥n de Traductores

Tema 3. Compilaci√≥n y Enlazado de Programas

## Definici√≥n de Gram√°tica

Una gram√°tica proporciona una especificaci√≥n sint√°ctica precisa de un lenguaje de programaci√≥n.

La complejidad de la verificaci√≥n sint√°ctica depende del tipo de gram√°tica que define el lenguaje.

Una gram√°tica se define como G = (V N , V T , P, S) , donde:

- ¬∑ VN es el conjunto de s√≠mbolos no terminales.
- ¬∑ VT es el conjunto de s√≠mbolos terminales.
- ¬∑ P es el conjunto de producciones o reglas gramaticales.
- ¬∑ S es el s√≠mbolo inicial (es un s√≠mbolo no terminal).

## 3.2 Construcci√≥n de Traductores

Tema 3. Compilaci√≥n y Enlazado de Programas

## Definici√≥n de Traductor

Traductor es un programa que recibe como entrada un texto en un lenguaje de programaci√≥n concreto y produce, como salida, un texto en lenguaje m√°quina equivalente.

Entrada --&gt; lenguaje fuente , que define a una m√°quina virtual.

Salida   --&gt; lenguaje objeto , que define a una m√°quina real.

Existen dos tipos de traductores:

- ¬∑ Compilador.
- ¬∑ Int√©rprete .

## 3.2 Construcci√≥n de Traductores

Tema 3. Compilaci√≥n y Enlazado de Programas

## Definici√≥n de Compilador

Compilador: traduce la especificaci√≥n de entrada a lenguaje m√°quina incompleto y con instrucciones m√°quina incompletas -&gt; se necesita un complemento llamado enlazador.

Enlazador (linker): completa los programas ligando las instrucciones m√°quina necesarias (a√±ade rutinas binarias de funcionalidades no programadas directamente en el programa fuente) y genera un programa ejecutable para la m√°quina real.



## 3.2 Construcci√≥n de Traductores

Tema 3. Compilaci√≥n y Enlazado de Programas

## Definici√≥n de Int√©rprete

Int√©rprete: lee un programa fuente escrito para una m√°quina virtual, realiza la traducci√≥n de manera interna y ejecuta una a una las instrucciones obtenidas para la m√°quina real.

No se genera ning√∫n programa objeto equivalente al descrito en el programa fuente.



DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

## 3.2 Construcci√≥n de Traductores

Fundamentos del Software

Tema 3. Compilaci√≥n y Enlazado de Programas

## Esquema de Traducci√≥n



## 3.2 Construcci√≥n de Traductores

Tema 3. Compilaci√≥n y Enlazado de Programas

Definici√≥n de Gram√°tica: conceptos previos [Aho08] (pp. 117-118, 197)

Alfabeto

: conjunto finito de s√≠mbolos.

Ejemplo: Binario = { 0, 1 }

Cadena

: secuencia finita de s√≠mbolos usando un alfabeto concreto.

Ejemplos: 110,  0110, 1, 00011

S√≠mbolos terminales : elementos de un alfabeto usados para formar cadenas.

Ejemplos: 0, 1

S√≠mbolos no terminales : variables sint√°cticas que representan conjuntos de cadenas (en el ejemplo, ser√≠a N). Se utilizan en las reglas gramaticales y no son elementos del alfabeto.

Ejemplo: N -&gt; N 0  | N 1  |  0  |   1

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

## 3.2 Construcci√≥n de Traductores

## Ejemplo

Dada la gram√°tica siguiente:

<!-- formula-not-decoded -->

id

Y el texto de entrada: id+id*(id-(id/id))

Usando las reglas de formaci√≥n gramatical, se obtendr√≠a una representaci√≥n ( √°rbol sint√°ctico ) que valida la construcci√≥n del texto de entrada ÔÉû verificaci√≥n sint√°ctica correcta.

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

Fundamentos del Software

Tema 3. Compilaci√≥n y Enlazado de Programas

E

E

id

E

## 3.3 Proceso de Compilaci√≥n: Fases de Traducci√≥n

Tema 3. Compilaci√≥n y Enlazado de Programas

Fases en la construcci√≥n de un traductor [Aho08] (pp. 4-11)



## 3.3 Fases de Traducci√≥n

## An√°lisis L√©xico. Funci√≥n Principal y Conceptos [Aho08] (pp. 109-111)

Funci√≥n : Leer los caracteres de la entrada del programa fuente, agruparlos en lexemas (palabras) y producir como salida una secuencia de tokens para cada lexema en el programa fuente (eliminando caracteres superfluos y comentarios).

Conceptos que surgen del Analizador L√©xico:

- ¬∑ Lexema o Palabra : Secuencia de caracteres del alfabeto con significado propio.
- ¬∑ Token : Concepto asociado a un conjunto de lexemas que, seg√∫n la gram√°tica del lenguaje fuente, tienen la misma misi√≥n sint√°ctica (en algunos casos, llevar√° asociado un valor de atributo).
- ¬∑ Patr√≥n : Descripci√≥n de la forma que pueden tomar los lexemas de un token.



## 3.3 Fases de Traducci√≥n

Tema 3. Compilaci√≥n y Enlazado de Programas

## An√°lisis L√©xico. Funci√≥n Principal y Conceptos. Ejemplo

| Token   | Descripci√≥n informal               | Lexemas de ejemplo      |
|---------|------------------------------------|-------------------------|
| IF      | Caracteres 'i' y 'f'               | if                      |
| ELSE    | Caracteres 'e', 'l', 's' y 'e'     | else                    |
| OP_COMP | Operadores <, >, <=, >=, !=, ==    | <=, ==, !=, ‚Ä¶           |
| IDENT   | Letra seguida por letras y d√≠gitos | pi, dato1, dato3, D3    |
| NUMERO  | Cualquier constante num√©rica       | 0, 210, 23.45, 0.899, ‚Ä¶ |

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

## 3.3 Fases de Traducci√≥n

## An√°lisis L√©xico. Funci√≥n Principal y Conceptos. Error L√©xico

En muchos lenguajes de programaci√≥n se consideran la mayor√≠a de los siguientes tokens:

- ¬∑ Un token para cada palabra reservada (if, do, while, else, ‚Ä¶).
- ¬∑ Los tokens para los operadores (individuales o agrupados).
- ¬∑ Un token que representa a todos los identificadores tanto de variables como de subprogramas.
- ¬∑ Uno o m√°s tokens que representan a las constantes (n√∫meros y cadenas de literales).
- ¬∑ Un token para cada signo de puntuaci√≥n (par√©ntesis izquierdo, par√©ntesis derecho, llave izquierda, llave derecha, coma, punto, punto y coma, corchete derecho, corchete izquierdo, ‚Ä¶).

Error l√©xico : Se producir√° cuando el car√°cter de la entrada no tenga asociado a ninguno de los patrones disponibles en nuestra lista de tokens (ej: car√°cter extra√±o en la formaci√≥n de una palabra reservada: whi¬øle ).



## 3.3 Fases de Traducci√≥n

## An√°lisis L√©xico. Especificaci√≥n de los Tokens usando expresiones regulares

Se pueden usar expresiones regulares para identificar un patr√≥n de s√≠mbolos del alfabeto como pertenecientes a un token determinado:

- 1 Cero 0 mas veces , operador
- 2 Uno 0 m√°s veces , operador +: r* = r+|X.
- 3 Cero 0 una operador ? vez,
- Una forma c√≥moda de definir clases de caracteres es de la siguiente forma:

<!-- formula-not-decoded -->

## 3.3 Fases de Traducci√≥n

## An√°lisis L√©xico. Especificaci√≥n de los Tokens. Ejemplo

Dada la gram√°tica mostrada anteriormente, los patrones que van a definir a los tokens ser√≠an los que muestra la tabla de la derecha:

<!-- formula-not-decoded -->

| ID      |                 |
|---------|-----------------|
|         | 'if'            |
| THEN    | 'then'          |
| PAR_IZQ | '('             |
| PAR_DER | ')'             |
| OP_BIN  | '+'|'-'|'*'|'/' |

## 3.3 Fases de Traducci√≥n

Tema 3. Compilaci√≥n y Enlazado de Programas

## An√°lisis Sint√°ctico

Las gram√°ticas ofrecen beneficios considerables tanto para los que dise√±an lenguajes como para los que dise√±an los traductores. Entre ellos destacamos los siguientes:

- ¬∑ Una gram√°tica proporciona una especificaci√≥n sint√°ctica precisa de un lenguaje de programaci√≥n.
- ¬∑ A partir de ciertas clases gramaticales es posible construir de manera autom√°tica un analizador sint√°ctico eficiente.
- ¬∑ Permiten revelar ambig√ºedades sint√°cticas y puntos problem√°ticos en el dise√±o del lenguaje.
- ¬∑ Una gram√°tica permite que el lenguaje pueda evolucionar o se desarrolle de forma iterativa agregando nuevas construcciones.

## 3.3 Fases de Traducci√≥n

Tema 3. Compilaci√≥n y Enlazado de Programas

## Funci√≥n del Analizador Sint√°ctico

Objetivo : Analizar las secuencias de tokens y comprobar  que  son  correctas sint√°cticamente.

A partir de una secuencia de tokens el analizador sint√°ctico nos devuelve:

- -  Si  la  secuencia  es  correcta  o  no  sint√°cticamente  (existe  un  conjunto  de  reglas gramaticales aplicables para poder estructurar la secuencia de tokens).
- - El orden en el que hay que aplicar las producciones de la gram√°tica para obtener la secuencia de entrada ( √°rbol sint√°ctico ).



Si  no  se  encuentra  un  √°rbol  sint√°ctico  para  una  secuencia  de  entrada,  entonces  la secuencia de entrada es incorrecta sint√°cticamente (tiene errores sint√°cticos).

## 3.3 Fases de Traducci√≥n

Tema 3. Compilaci√≥n y Enlazado de Programas

## An√°lisis Sint√°ctico. Gram√°ticas Libres de Contexto [Aho08] (pp.197)

Una gram√°tica definida como G = (V N , V T , P, S) , donde:

- ¬∑ VN es el conjunto de s√≠mbolos no terminales.
- ¬∑ VT es el conjunto de s√≠mbolos terminales.
- ¬∑ P es el conjunto de producciones o reglas gramaticales.
- ¬∑ S es el s√≠mbolo inicial.

Se dice que es una gram√°tica libre de contexto cuando el conjunto de producciones P es de la forma:

<!-- formula-not-decoded -->

Es decir, solo admite tener un s√≠mbolo no terminal en la parte izquierda de las producciones. La denominaci√≥n libre de contexto se debe a que donde aparezca A se podr√≠a poner a , independientemente del contexto en el que se encuentre A.

## 3.3 Fases de Traducci√≥n

Tema 3. Compilaci√≥n y Enlazado de Programas

## An√°lisis Sint√°ctico. Gram√°ticas ambiguas

Una gram√°tica es ambigua cuando admite m√°s de un √°rbol sint√°ctico para una misma secuencia de s√≠mbolos de entrada.

ecuencia de entrada Ejemplo : Dadas las producciones de la gram√°tica del ejemplo de la diapositiva 9 y dada la misma s id+id*id , se puede apreciar que le pueden corresponder dos √°rboles sint√°cticos.



Cuando programamos en un determinado lenguaje:

- ¬∑ ¬øA qu√© nos referimos cuando hablamos de ' precedencia de operadores '?
- ¬∑ ¬øPor qu√© hay que utilizar los par√©ntesis para evitar la precedencia de operador ?

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

## 3.3 Fases de Traducci√≥n

Tema 3. Compilaci√≥n y Enlazado de Programas

## An√°lisis Sem√°ntico

La sem√°ntica de un lenguaje de programaci√≥n es el significado dado a las distintas construcciones sint√°cticas.

En los lenguajes de programaci√≥n, el significado est√° ligado a la estructura sint√°ctica de las sentencias.

Ejemplo : En una sentencia de asignaci√≥n, seg√∫n la sintaxis del lenguaje C, expresada mediante la producci√≥n siguiente:

## sent\_asignacion ÔÇÆ IDENTIFICADOR   OP\_ASIG   expresion   PYC

donde IDENTIFICADOR , OP\_ASIG y PYC son s√≠mbolos terminales (tokens) que representan, respectivamente, a una variable, el operador de asignaci√≥n '=' y al delimitador de sentencia ';', deben cumplirse las siguientes reglas sem√°nticas:

- ¬∑ IDENTIFICADOR debe estar previamente declarado.
- ¬∑ El tipo de la expresion debe ser acorde con el tipo del IDENTIFICADOR .

## 3.3 Fases de Traducci√≥n

Tema 3. Compilaci√≥n y Enlazado de Programas

## An√°lisis Sem√°ntico

- ¬∑ Durante la fase de an√°lisis sem√°ntico se producen errores cuando se detectan construcciones sin un significado correcto (p.e. variable no declarada, tipos incompatibles en una asignaci√≥n, llamada a un procedimiento incorrecto o con n√∫mero de argumentos incorrectos, ‚Ä¶).
- ¬∑ En lenguaje C es posible realizar asignaciones entre variables de distintos tipos, aunque algunos compiladores devuelven warnings o avisos de que algo puede realizarse mal a posteriori.
- ¬∑ Otros lenguajes impiden la asignaci√≥n de datos de diferente tipo (lenguaje Pascal).

## 3.3 Fases de Traducci√≥n

Tema 3. Compilaci√≥n y Enlazado de Programas

## Generaci√≥n de C√≥digo

- ¬∑ En esta fase se genera un archivo con un c√≥digo en lenguaje objeto (generalmente lenguaje m√°quina) con el mismo significado que el texto fuente.
- ¬∑ En algunos, se intercala una fase de generaci√≥n de c√≥digo intermedio para proporcionar independencia de las fases de an√°lisis con respecto al lenguaje m√°quina (portabilidad del compilador) o para hacer m√°s f√°cil la optimizaci√≥n de c√≥digo.

## 3.3 Fases de Traducci√≥n

Tema 3. Compilaci√≥n y Enlazado de Programas

## Optimizaci√≥n de C√≥digo

- ¬∑ Esta fase existe para mejorar el c√≥digo mediante comprobaciones locales a un grupo de instrucciones (bloque b√°sico) o a nivel global.
- ¬∑ Se pueden realizar optimizaciones de c√≥digo tanto al c√≥digo intermedio (si existe) como al c√≥digo objeto final. Generalmente, las optimizaciones se aplican a c√≥digos intermedios.

Ejemplo : Una asignaci√≥n dentro de un bucle for en lenguaje C:

```
.... for (i=0; i<1000; i++) { r= 37.0-i*35; b= 7.5; z= b-sin(-r/35000); } .... b= 7.5; for (i=0; i<1000; i++) { r= 37.0-i*35; z= b-sin(-r/35000); }
```

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

## 3.3 Fases de Traducci√≥n

Fundamentos del Software

Tema 3. Compilaci√≥n y Enlazado de Programas

## Fases de Traducci√≥n. Ejemplo (1/2) [Aho08]



DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

## 3.3 Fases de Traducci√≥n

Fundamentos del Software

Tema 3. Compilaci√≥n y Enlazado de Programas

## Fases de Traducci√≥n. Ejemplo (2/2) [Aho08]

asign ident

(+)

opbin ident

ident

Analizador Sem√°ntco identl

identz ident3



entareal

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

LENGUAJES Y SISTEMAS INFORM√ÅTICOS

const

## 3.4 Int√©rpretes

Tema 3. Compilaci√≥n y Enlazado de Programas

## Int√©rpretes

Int√©rprete : hace que un programa fuente escrito en un lenguaje vaya, sentencia a sentencia, traduci√©ndose y ejecut√°ndose directamente por el computador.

Consecuencias inmediatas:

- ¬∑ No se crea un archivo o programa objeto almacenable en memoria para posteriores ejecuciones, es decir, cada vez que se ejecute el programa hay que volver a analizarlo.
- ¬∑ La ejecuci√≥n del programa escrito en lenguaje fuente est√° supervisada por el int√©rprete.
- ¬∑ Las instrucciones de los bucles se analizan en cada iteraci√≥n.
- ¬∑ La optimizaci√≥n solo se puede hacer a nivel de instrucci√≥n, no de estructuras, ni bloques, ni programas.
- ¬∑ Ejemplo : Bash.

## 3.4 Int√©rpretes

## Int√©rpretes

## ¬øCu√°ndo es √∫til un int√©rprete?

- ¬∑ El programador trabaja en un entorno interactivo y se desean obtener los resultados de la ejecuci√≥n de una instrucci√≥n antes de ejecutar la siguiente.
- ¬∑ El programador lo ejecuta escasas ocasiones y el tiempo de ejecuci√≥n no es importante.
- ¬∑ Las instrucciones del lenguaje tiene una estructura simple y pueden ser analizadas f√°cilmente.
- ¬∑ Cada instrucci√≥n ser√° ejecutada una sola vez.

Tema 3. Compilaci√≥n y Enlazado de Programas

## ¬øCu√°ndo no es √∫til un int√©rprete?

- ¬∑ Si las instrucciones del lenguaje son complejas.
- ¬∑ Los programas van a trabajar en modo de producci√≥n y la velocidad es importante.
- ¬∑ Las instrucciones ser√°n ejecutadas con frecuencia.

## 3.5 Modelos de Memoria de un Proceso

Tema 3. Compilaci√≥n y Enlazado de Programas

## Modelo de Memoria de un Proceso [Carr07] (pp.219-231)

Elementos responsables de la gesti√≥n de memoria:

- ¬∑ Lenguaje de programaci√≥n.
- ¬∑ Compilador.
- ¬∑ Enlazador.
- ¬∑ Sistema operativo.
- ¬∑ Hardware para la gesti√≥n de memoria: MMU - Memory Management Unit.

## 3.5 Modelos de Memoria de un Proceso

Tema 3. Compilaci√≥n y Enlazado de Programas

## Niveles de la Gesti√≥n de Memoria

- ¬∑ Nivel de procesos - reparto de memoria entre los procesos. Responsabilidad del SO.

## Aumenta el nivel de detalle

- ¬∑ Nivel de regiones - distribuci√≥n del espacio asignado a las regiones de un proceso.  Gestionado por el SO aunque la divisi√≥n en regiones la hace el compilador.
- ¬∑ Nivel de zonas - reparto de una regi√≥n entre las diferentes zonas (nivel est√°tico, din√°mico basado en pila y din√°mico basado en heap) de esta. Gesti√≥n del lenguaje de programaci√≥n con soporte del SO.

## 3.5 Modelos de Memoria de un Proceso

## Necesidades de Memoria de un Proceso

- ¬∑ Tener un espacio l√≥gico independiente.
- ¬∑ Espacio protegido del resto de procesos.
- ¬∑ Posibilidad de compartir memoria.
- ¬∑ Soporte para diferentes regiones.
- ¬∑ Facilidades de depuraci√≥n.
- ¬∑ Uso de un mapa amplio de memoria.
- ¬∑ Uso de diferentes tipos de objetos de memoria.
- ¬∑ Persistencia de datos.
- ¬∑ Desarrollo modular.
- ¬∑ Carga din√°mica de m√≥dulos (por ejemplo, plug-in).

Tema 3. Compilaci√≥n y Enlazado de Programas

## 3.5 Modelos de Memoria de un Proceso

Tema 3. Compilaci√≥n y Enlazado de Programas

## Modelo de Memoria de un Proceso [Carr07] (pp.246-251)

Estudiaremos aspectos relacionados con la gesti√≥n del mapa de memoria de un proceso, desde la generaci√≥n del ejecutable a su carga en memoria:

- ¬∑ Nivel de regiones.
- ¬∑ Nivel de zonas.

## Para ello veremos:

- ¬∑ Implementaci√≥n de tipos de objetos necesarios para un programa y su correspondencia con el mapa de memoria.
- ¬∑ Ciclo de vida de un programa.
- ¬∑ Estructura de un ejecutable.
- ¬∑ Bibliotecas.

## 3.5 Modelos de Memoria de un Proceso

Tema 3. Compilaci√≥n y Enlazado de Programas

## Tipos de Datos (desde el punto de vista de su implementaci√≥n en memoria)

- ¬∑ Datos est√°ticos:
- ¬∑ Globales a todo el programa, m√≥dulo o locales a una funci√≥n (√°mbito de visibilidad de una variable).
- ¬∑ Constantes o variables.
- ¬∑ Con o sin valor inicial - implementaci√≥n con direccionamiento absoluto o direccionamiento relativo (PIC - c√≥digo independiente de la posici√≥n).
- ¬∑ Datos din√°micos asociados a la ejecuci√≥n de una funci√≥n:
- ¬∑ Se almacenan en pila en un registro de activaci√≥n (contiene variables locales, par√°metros, direcci√≥n de retorno) .
- ¬∑ Se crean al activar una funci√≥n y se destruyen al terminar la misma.
- ¬∑ Datos din√°micos controlados por el programa heap (zona de memoria usada tiempo de ejecuci√≥n para albergar los datos no conocidos en tiempo de compilaci√≥n).

## Espacio de direcciones de un proceso



## 3.5 Modelos de Memoria de un Proceso

Tema 3. Compilaci√≥n y Enlazado de Programas

## Ejemplo de evoluci√≥n de la Pila (Stack) en la ejecuci√≥n de un programa

#include &lt;stdio.h&gt;

int a();

int b();

int c();



## 3.5 Modelos de Memoria de un Proceso

Tema 3. Compilaci√≥n y Enlazado de Programas

## C√≥digo Independiente de la Posici√≥n (PIC, Position Independent Code )

- ¬∑ Un fragmento de c√≥digo cumple esta propiedad si puede ejecutarse en cualquier parte de la memoria.
- ¬∑ Es necesario que todas sus referencias a instrucciones o datos no sean absolutas sino relativas a un registro, por ejemplo, contador de programa.



Suponemos instrucciones que ocupan 4 direcciones de memoria , por lo tanto, el incremento del PC se produce en 4.

## 3.5 Modelos de Memoria de un Proceso

Tema 3. Compilaci√≥n y Enlazado de Programas

## Ejemplos de diferentes Objetos de Memoria

```
int a ; /* variable est√Ütica global sin valor inicial     */ int b= 8; /* variable est√Ütica global con valor inicial     */ static int c; /* variable est√Ütica de m√≥dulo sin valor inicial  */ static int d= 8; /* variable est√Ütica de m√≥dulo con valor inicial  */ const int e= 8; /* constante est√Ütica global                      */ static const int f= 8;  /* constante est√Ütica de m√≥dulo                   */ extern int g; /* referencia a variable global de otro m√≥dulo    */ void funcion ( int h) /* par√Ümetro: variable din√Ümica de funci√≥n        */ { int i; /* variable din√Ümica de funci√≥n sin valor inicial */ int j= 8; /* variable din√Ümica de funci√≥n con valor inicial */ static int k; /* variable est√Ütica local sin valor inicial      */ static int l= 8; /* variable est√Ütica local con valor inicial      */ { int m; /* variable din√Ümica de bloque sin valor inicial  */ int n= 8; /* variable din√Ümica de bloque con valor inicial  */ } . . . . }
```

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

## 3.6 Ciclo de Vida de un Programa

## Ciclo de vida de un programa [Carr07] (pp. 254-262)

A partir de un c√≥digo fuente, un programa debe pasar por varias fases antes de poder ejecutarse:

- 1. Preprocesado (archivos .i en C).
- 2. Compilaci√≥n (archivos .s en C).
- 3. Ensamblado (archivos .o en C).
- 4. Enlazado (archivos .exe y a.out).
- 5. Carga y Ejecuci√≥n.

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

LENGUAJES Y SISTEMAS INFORM√ÅTICOS

Fundamentos del Software

Tema 3. Compilaci√≥n y Enlazado de Programas

C√≥digo fuente

,

hello.c hello.cc

C√≥digo precompilado hello.i

Precompilador

Compilador

C/C++

C√≥digo en ensamblador hello.s

Archivo objeto hello.o

Enlazador

Archivo ejecutable/binario

hello, hello.exe

Almacenado en el DD

Cargador del SO

Ejecuci√≥n de un programa (proceso)

Espacio de direcciones del proceso

Memoria RAM

Assembler

C√≥digo objeto relocalizable

Otros archivos objeto/m√≥dulos

Bibliotecas

Bibliotecas

(enlace diferido)

## 3.6 Ciclo de Vida de un Programa

## Ejemplo de Compilaci√≥n

gcc/g++ es un wrapper (envoltorio) que invoca a:

bash:~$ gcc -v ejemplo.c

```
cpp1 ...  // preprocesador cc ‚Ä¶ // compilador as ‚Ä¶ // ensamblador collect2 ‚Ä¶// wrapper que invoca al enlazador ld
```

Podemos salvar los archivos temporales con:

<!-- formula-not-decoded -->

Podemos generar el archivo ensamblador con:

<!-- formula-not-decoded -->

El archivo objeto con:

<!-- formula-not-decoded -->

Enlazar un objeto para generar el ejecutable con:

bash:~$ ld objeto.o -o eje

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

## Fundamentos del Software

Tema 3. Compilaci√≥n y Enlazado de Programas

```
.section        __TEXT,__text,regular,pure_instructions .macosx_version_min 10, 13 .globl  _main .p2align        4, 0x90 _main:                                  ## @main .cfi_startproc ## BB#0: pushq   %rbp Lcfi0: .cfi_def_cfa_offset 16 Lcfi1: .cfi_offset %rbp, -16 movq    %rsp, %rbp Lcfi2: .cfi_def_cfa_register %rbp subq    $16, %rsp leaq    L_.str(%rip), %rdi movl    _x(%rip), %esi movb    $0, %al callq   _printf xorl    %esi, %esi movl    %eax, -4(%rbp)          ## 4-byte Spill movl    %esi, %eax addq    $16, %rsp popq    %rbp retq .cfi_endproc .section        __DATA,__data .globl  _x                      ## @x .p2align        2 _x: .long   42                      ## 0x2a .section        __TEXT,__cstring,cstring_literals L_.str:                                 ## @.str .asciz  "Hola mundo, x = %d\n" .subsections_via_symbols
```

## 3.6 Ciclo de Vida de un Programa

Tema 3. Compilaci√≥n y Enlazado de Programas

## Compilaci√≥n

El compilador procesa cada uno de los archivos de c√≥digo fuente para generar el correspondiente archivo objeto.

## Realiza las siguientes acciones:

- o Genera c√≥digo objeto y calcula cu√°nto espacio ocupan los diferentes tipos de datos.
- o Asigna direcciones a los s√≠mbolos est√°ticos (instrucciones o datos) y resuelve las referencias bien de forma absoluta o relativa (necesita reubicaci√≥n).
- o Las referencias a s√≠mbolos din√°micos se resuelven usando direccionamiento relativo a pila para datos relacionados a la invocaci√≥n de una funci√≥n, o con direccionamiento indirecto para el heap. No necesitan reubicaci√≥n al no aparecer en el archivo objeto.
- o Genera la Tabla de s√≠mbolos e informaci√≥n de depuraci√≥n .

## 3.6 Ciclo de Vida de un Programa

## Ejemplo

## Programa ejemplo:

## Tabla de s√≠mbolos:

```
include <stdio.h> x = 42; () printf (' Hola Mundo, x = %d\ n', x); $ gcc -c hola.c $ nm hola.o 0000000000000000 T _ main U _ printf 000000000000002 c D _x
```

```
# int int main { }
```

nm : orden Linux para ver las diferentes secciones de un archivo .o (y con opci√≥n -a se pueden ver s√≠mbolos que pueden depurarse):

T indica secci√≥n de Texto (instrucciones m√°quina del programa). U indica objetos no definidos en el programa (cadena de printf). D indica secci√≥n de Datos (la variable global x).

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

Tema 3. Compilaci√≥n y Enlazado de Programas

## 3.6 Ciclo de Vida de un Programa

Tema 3. Compilaci√≥n y Enlazado de Programas

## Enlazado

El enlazador (linker) debe agrupar los archivos objetos de la aplicaci√≥n y las bibliotecas, y resolver las referencias entre ellos.

En ocasiones debe realizar reubicaciones dependiendo del esquema de gesti√≥n de memoria utilizado.



## 3.6 Ciclo de Vida de un Programa

Tema 3. Compilaci√≥n y Enlazado de Programas

## Funciones del Enlazador

- ¬∑ Se completa la etapa de resoluci√≥n de s√≠mbolos externos utilizando la tabla de s√≠mbolos.
- ¬∑ Se agrupan las zonas de caracter√≠sticas similares de los diferentes m√≥dulos en regiones (c√≥digo, datos inicializados o no, etc.) .
- ¬∑ Se realiza la reubicaci√≥n de m√≥dulos formando regiones - hay que transformar las referencias dentro de un m√≥dulo a referencias dentro de las regiones. Tras esta fase cada archivo objeto tiene una lista de reubicaci√≥n que contiene los nombres de los s√≠mbolos y los desplazamientos dentro del archivo que deben a√∫n parchearse.

## 3.6 Ciclo de Vida de un Programa

Tema 3. Compilaci√≥n y Enlazado de Programas

## Agrupamiento de m√≥dulos en regiones



## 3.6 Ciclo de Vida de un Programa

## Tipos de enlazado y √°mbito

- ¬∑ Atributos de enlazado : externo, interno o sin enlazado.
- ¬∑ Los tipos de enlazado definen una especie de √°mbito :
- ¬∑ Enlazado externo --&gt; visibilidad global.
- ¬∑ Enlazado interno --&gt; visibilidad de fichero.
- ¬∑ Sin enlazado --&gt; visibilidad de bloque.
- ¬∑ El tipo de enlazado indica si el mismo nombre (de una variable o funci√≥n) en otro √°mbito se refiere al mismo objeto o a otro distinto. Esto permite definir la visibilidad de los identificadores.

Tema 3. Compilaci√≥n y Enlazado de Programas

## 3.6 Ciclo de Vida de un Programa

Tema 3. Compilaci√≥n y Enlazado de Programas

## Ejemplo

| void   | func( int );                         | Objeto   | Tipo             |
|--------|--------------------------------------|----------|------------------|
| {      | int main ()                          | x        | Enlazado externo |
|        |                                      | st       | Enlazado interno |
| for    | (x = 0; x < 10; x++)        func(x); | func     | Enlazado externo |
| }      |                                      | j        | Sin enlazado     |



DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

## 3.6 Ciclo de Vida de un Programa

Tema 3. Compilaci√≥n y Enlazado de Programas

## Carga en memoria principal y Ejecuci√≥n

La reubicaci√≥n del proceso se realiza en la carga (reubicaci√≥n est√°tica) o en ejecuci√≥n (reubicaci√≥n din√°mica) y es funci√≥n del Sistema Operativo ayudado por un hardware espec√≠fico (MMU - Unidad de Gesti√≥n de Memoria). Depende del tipo de gesti√≥n de memoria que se realice:

- ¬∑ Paginaci√≥n.
- ¬∑ Segmentaci√≥n.

## 3.6 Ciclo de Vida de un Programa

Tema 3. Compilaci√≥n y Enlazado de Programas

## Diferencias entre archivos objeto y archivos ejecutables

- ¬∑ Los archivos objeto (resultado de la compilaci√≥n) y ejecutable (resultado del enlazado) son muy similares en cuanto a contenidos.
- ¬∑ Su principales diferencias son:
- ¬∑ En el ejecutable la cabecera del archivo contiene el punto de inicio del mismo, es decir, la primera instrucci√≥n que se cargar√° en el PC.
- ¬∑ En cuanto a las regiones, s√≥lo hay informaci√≥n de reubicaci√≥n si √©sta se ha de realizar en la carga.

## 3.6 Ciclo de Vida de un Programa

Fundamentos del Software

Tema 3. Compilaci√≥n y Enlazado de Programas

## Formato de archivo ejecutable



## 3.6 Ciclo de Vida de un Programa

Tema 3. Compilaci√≥n y Enlazado de Programas

## Formatos de archivo objeto y ejecutables

|      | Descripci√≥n                                                                                                                                                                                                       |
|------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|      | Es el formato original de los sistemas Unix  Consta de tres secciones: text, data y bss que se corresponden con el c√≥digo; datos inicializados y sin inicializar. No tiene informaci√≥n para depuraci√≥n.           |
| COFF | El Common Object File Format posee m√∫ltiples secciones cada una con su cabecera pero est√°n limitadas en n√∫mero.  Aunque permite inforaci√≥n de depuraci√≥n; √©sta es limitada. Es el formato utilizado por Windows . |
| ELF  | Executable and Linking Format es similar al COFF pero elimina algunas de restricciones. Se utiliza en los sistemas Unix modernos; incluido GNU/Linux y Solaris.                                                   |

## 3.6 Ciclo de Vida de un Programa

## Ejemplos de secciones de un archivo ejecutable ELF (readelf)

- ÔÇß .text -Instrucciones . Compartida por todos los procesos que ejecutan el mismo binario. Permisos: r y w. Es de las regiones m√°s afectada por la optimizaci√≥n realizada por parte del compilador.
- ÔÇß .bss -Block Started by Symbol : datos no inicializados y variables est√°ticas. El archivo objeto almacena su tama√±o pero no los bytes necesarios para su contenido.
- ÔÇß .data -Variables globales y est√°ticas inicializadas . Permisos: r y w.
- ÔÇß .rdata o .rodata -Constantes o cadenas literales .
- ÔÇß .reloc - Informaci√≥n de reubicaci√≥n para la carga .
- ÔÇß Tabla de s√≠mbolos - Informaci√≥n necesaria ( nombre y direcci√≥n ) para localizar y reubicar definiciones y referencias simb√≥licas del programa. Cada entrada representa un s√≠mbolo .
- ÔÇß Registros de reubicaci√≥n - Informaci√≥n utilizada por el enlazador para ajustar los contenidos de las secciones a reubicar.

## 3.7 Bibliotecas

## Definiciones [Carr07] (pp.262-264)

- ¬∑ Biblioteca: colecci√≥n de objetos, normalmente relacionados entre s√≠.
- ¬∑ Las bibliotecas favorecen modularidad y reusabilidad de c√≥digo.
- ¬∑ Podemos clasificarlas seg√∫n la forma de enlazarlas:
- ¬∑ Bibliotecas est√°ticas - se ligan con el programa en el enlazado ( .a )
- ¬∑ Bibliotecas din√°micas - se ligan con el programa en ejecuci√≥n ( .so )

Tema 3. Compilaci√≥n y Enlazado de Programas

## Figure 2. Static vs. dynamic linking





## 3.7 Bibliotecas

Fundamentos del Software

Tema 3. Compilaci√≥n y Enlazado de Programas

## Bibliotecas Est√°ticas

Una biblioteca est√°tica es b√°sicamente un conjunto de archivos objeto que se copian en un √∫nico archivo que forma la biblioteca.

Pasos para su creaci√≥n:

- ÔÇß
- Construimos el c√≥digo fuente: double media(double a, double b) { return (a+b) / 2; }
- ÔÇß Generamos el objeto: gcc -c calc\_mean.c -o calc\_mean.o
- ÔÇß
- Archivamos el objeto (creamos la biblioteca): ar rcs libmean.a  calc\_mean.o
- ÔÇß Utilizamos la biblioteca:

gcc -static prueba.c -L. -lmean -o statically\_linked

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

## 3.7 Bibliotecas

## Bibliotecas Est√°ticas

Inconvenientes de las bibliotecas est√°ticas:

- ¬∑ El c√≥digo de la biblioteca est√° en todos los ejecutables que la usan, lo que desperdicia disco y memoria principal.
- ¬∑ Si actualizamos una biblioteca est√°tica, debemos recompilar los programas que la usan para que se puedan beneficiar de la nueva versi√≥n.
- ¬∑ Producen ejecutables grandes.

Tema 3. Compilaci√≥n y Enlazado de Programas

## 3.7 Bibliotecas

Tema 3. Compilaci√≥n y Enlazado de Programas

## Bibliotecas Din√°micas

Las bibliotecas din√°micas se integran con los procesos que las usan en tiempo de ejecuci√≥n, por ello se realiza previamente la reubicaci√≥n de m√≥dulos.

Resuelven los inconvenientes que presentan las bibliotecas est√°ticas.

El archivo correspondiente a una biblioteca din√°mica se diferencia de un archivo ejecutable en los siguientes aspectos:

- ¬∑ Contiene informaci√≥n de reubicaci√≥n.
- ¬∑ Contiene una tabla de s√≠mbolos.
- ¬∑ En la cabecera no se almacena informaci√≥n de punto de entrada.

Al usar una biblioteca din√°mica, en el proceso de montaje del programa ejecutable se incluye un m√≥dulo de montaje din√°mico (enlazador din√°mico) : carga y monta las bibliotecas din√°micas usadas por el programa durante su ejecuci√≥n.

## 3.7 Bibliotecas

Tema 3. Compilaci√≥n y Enlazado de Programas

## Estructura de un ejecutable que usa bibliotecas din√°micas (1/2)



PTL - Procedure Linkaje Table en ELF (tabla de s√≠mbolos e informaci√≥n de reubicaci√≥n )

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

## 3.7 Bibliotecas

Tema 3. Compilaci√≥n y Enlazado de Programas

## Estructura de un ejecutable que usa bibliotecas din√°micas (2/2)



ld.so.1 es el enlazador din√°mico que est√° en el c√≥digo del ejecutable x es una direcci√≥n f√≠sica de memoria principal donde comienza el c√≥digo de la funci√≥n malloc

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

## 3.7 Bibliotecas

## Creaci√≥n y uso de Bibliotecas Din√°micas

- ÔÇß Generamos el objeto de la biblioteca:

gcc -c -fPIC calc\_mean.c -o calc\_mean.o gcc -shared -Wl,-soname,libmean.so.1 -o libmean.so.1.0.1

- ÔÇß Creamos la bibloteca: calc\_mean.o
- ÔÇß Usamos la biblioteca:

gcc main.c -o dynamically\_linked -L. -lmean

- ÔÇß La orden para ver las bibliotecas que est√°n enlazadas con un programa es: ldd hola

Fundamentos del Software

Tema 3. Compilaci√≥n y Enlazado de Programas

## 3.8 Automatizaci√≥n del Proceso de Compilaci√≥n y Enlazado.

Tema 3. Compilaci√≥n y Enlazado de Programas

Automatizar la construcci√≥n es la t√©cnica utilizada durante el ciclo de vida de desarrollo de software donde la transformaci√≥n del c√≥digo fuente en el ejecutable se realiza mediante un gui√≥n (script).

La automatizaci√≥n mejora la calidad del resultado final y permite el control de versiones.

## Varias formas:

- ¬∑ Herramienta make - archivos makefile.
- ¬∑ IDE (Integrated Development Environment - Entornos de Desarrollo Integrados), que embebe los guiones y el proceso de compilaci√≥n y enlazado, p.e. CodeBlocks .
```



## üìÑ Archivo: [Teor√≠a] Transp.Tema4.SistemasDeArchivos.Intr.BasesDatos-2020.pdf

**M√©todo de extracci√≥n usado:** Docling

```markdown
Fundamentos del Software

1er Curso del Doble Grado en Ingenier√≠a Inform√°tica

## Tema 4. Sistemas de archivos. Introducci√≥n a las bases de datos.



- 4.1. Concepto de archivo y directorio.
- 4.2. Organizaci√≥n de archivos.
- 4.3. Bases de datos.
- 4.4. Sistema de gesti√≥n de la base de datos.
- ¬∑ Conocer los conceptos b√°sicos de archivo, registro, campo, directorio y estructura jer√°rquica de archivos.
- ¬∑ Conocer los distintos tipos de organizaci√≥n interna de archivos.
- ¬∑ Conocer las acciones involucradas en el acceso a un registro en cada una de las organizaciones posibles de un archivo.
- ¬∑ Comprender los problemas inherentes a la gesti√≥n de archivos frente al uso de una base de datos.
- ¬∑ Conocer las caracter√≠sticas de una base de datos.
- ¬∑ Conocer el concepto de sistema de gesti√≥n de base de datos y las funciones que debe cumplir.





[Prieto 06] A. Prieto, A. Lloris, J.C. Torres. Introducci√≥n a la Inform√°tica (4¬™ Edici√≥n) . McGraw-Hill, 2006.

## 4.1 Concepto de archivo y directorio

Tema 4. Sistemas de archivos. Introducci√≥n a las bases de datos

Concepto de archivo [Prie06] (pp. 595-598)

Archivo es un conjunto de informaci√≥n sobre un mismo tema, tratada como una unidad de almacenamiento en memoria secundaria y organizada de forma estructurada para la b√∫squeda de un dato individual.

Un archivo est√° compuesto de registros homog√©neos que contienen informaci√≥n sobre el tema.

Un registro es una estructura dentro del archivo que contiene la informaci√≥n correspondiente a un elemento individual.

Un registro se puede dividir en campos. Un campo es un dato que representa una informaci√≥n unitaria o independiente.

Tema 4. Sistemas de archivos. Introducci√≥n a las bases de datos

## Operaciones sobre archivos

El sistema operativo permite que el usuario pueda aludir al archivo mediante un nombre , independientemente de la forma en que se almacene en el dispositivo (p.e., un disco).

Todo archivo tiene asociados unos atributos , adem√°s del nombre, como: tama√±o, fecha de creaci√≥n y de modificaci√≥n, propietario, permisos de acceso, etc. (depender√° del sistema operativo).

El SO proporciona √≥rdenes o servicios para operar sobre los archivos como:

- ÔÇß Crear/copiar/borrar/renombrar un archivo.
- ÔÇß Establecer/obtener atributos de un archivo.
- ÔÇß Abrir/cerrar un archivo para el procesamiento de su contenido.
- ÔÇß Leer/escribir un registro de un determinado archivo.

Gesti√≥n de archivos [Prie06] (p. 596)

Gesti√≥n del acceso a archivos realizada por el sistema operativo



Tema 4. Sistemas de archivos. Introducci√≥n a las bases de datos

## Gesti√≥n de archivos: comentarios

- ¬∑ El sistema operativo transporta, cada vez que se accede al dispositivo, una cantidad fija de informaci√≥n que depende de las caracter√≠sticas f√≠sicas de √©ste: bloque o registro f√≠sico, de longitud distinta al tama√±o del registro.
- ¬∑ El sistema operativo transforma la direcci√≥n l√≥gica usada en los programas de usuario en la direcci√≥n f√≠sica con la que se direcciona en el dispositivo.
- ¬∑ Un archivo es una estructura de datos externa al programa que lo usa; en las operaciones de lectura/escritura se transfiere la informaci√≥n a/desde un buffer en memoria principal asociado a las operaciones de entrada/salida sobre el archivo.

## Clasificaci√≥n de archivos seg√∫n el tipo de registros

- 1. Longitud fija.
- 2. Longitud variable.
- ¬∑ Con delimitador: un determinado car√°cter llamado delimitador marca el fin de un registro (suelen usarse como delimitadores el salto de l√≠nea, nulo, etc.).
- ¬∑ Con cabecera: cada registro contiene un campo inicial que almacena el n√∫mero de bytes del registro.
- 3. Longitud indefinida : el sistema operativo no realiza ninguna gesti√≥n sobre la longitud de los registros ya que el archivo no tiene realmente ninguna estructura interna.
- ¬∑ En cada operaci√≥n de lectura/escritura se transfiere una determinada subcadena del archivo y ser√° el programa de usuario quien indique al SO el principio y final de ese registro.

Una posibilidad a√±adida: disponer de un campo clave (o llave) que permita localizar r√°pidamente un registro.

Tema 4. Sistemas de archivos. Introducci√≥n a las bases de datos

## Concepto de directorio

Directorio es un archivo especial que permite agrupar archivos seg√∫n las necesidades de los usuarios. En cada dispositivo existe una estructura jer√°rquica donde se localizan todos los archivos de los distintos usuarios que lo usan.

En la visi√≥n que el usuario tiene de la estructura jer√°rquica de archivos se utilizan los siguientes conceptos:

- ¬∑ Directorio actual o de trabajo.
- ¬∑ Directorio inicial o home.
- ¬∑ Rutas (pathname) absolutas y relativas.
- ¬∑ Lista de b√∫squeda.
- ¬∑ Enlace duro, enlace simb√≥lico.

El sistema operativo proporciona operaciones para manejar los conceptos anteriores.

## 4.2 Organizaci√≥n de archivos

Tema 4. Sistemas de archivos. Introducci√≥n a las bases de datos

## Organizaci√≥n secuencial [Prie06] (pp. 600-602)

Los registros est√°n almacenados f√≠sicamente de forma contigua.

Ejemplo de archivo secuencial almacenado en una cinta magn√©tica. (IRG: inter record gap)



## La organizaci√≥n secuencial es adecuada:

- ¬∑ Cuando se quiere leer los registros en la misma secuencia en que est√°n almacenados.
- ¬∑ Cuando se necesita leer la mayor√≠a de los registros del archivo.

## Ventajas :

- ¬∑ Buen aprovechamiento del espacio.
- ¬∑ Sencilla de utilizar .
- ¬∑ Se puede utilizar con dispositivos secuenciales que son de bajo precio.

## Organizaci√≥n secuencial: operaciones sobre archivos

- ÔÇß A√±adir. S√≥lo es posible escribir al final del archivo, despu√©s del √∫ltimo registro escrito.
- ÔÇß Consulta o recuperaci√≥n. Se realiza en orden secuencial, es decir, el orden en el que se hubieran escrito determina el orden en el que se leen los registros. Para leer el registro que ocupa la posici√≥n n en el archivo es necesario leer previamente los n-1 registros que hay antes que √©l.
- ÔÇß Inserci√≥n, modificaci√≥n y eliminaci√≥n. No es f√°cil realizar estas operaciones sobre un archivo secuencial.
- ¬∑ La modificaci√≥n de un registro solo es posible si no se aumenta su longitud.
- ¬∑ No es posible eliminar un registro del archivo, pero se puede realizar un borrado l√≥gico, es decir, marcarlo de tal forma que al leer se identifique como no v√°lido.
- ¬∑ En otros casos es necesario crear un archivo nuevo con las actualizaciones que se quieran realizar.

## Organizaci√≥n secuencial encadenada [Prie06] (pp. 602-604)

Junto a cada registro se almacena un puntero con la direcci√≥n f√≠sica del registro siguiente, dando lugar a una cadena de registros.

El √∫ltimo registro de la cadena contiene una marca especial en el lugar del puntero indicando que ya no hay m√°s registros en el archivo.



Principal ventaja : facilidad de inserci√≥n y borrado de registros.

Principal inconveniente : limita las consultas de forma secuencial.

## Organizaci√≥n secuencial encadenada: operaciones sobre archivos

- ÔÇß Consulta o recuperaci√≥n. La consulta es secuencial, al igual que en un archivo con organizaci√≥n secuencial pura. Cada vez que se lee un registro se lee la posici√≥n del siguiente, lo que permite seguir la secuencia l√≥gica del archivo.
- ÔÇß Inserci√≥n. Hay que seguir los siguientes pasos:
- 1. Localizar la posici√≥n donde se desea insertar; es decir, entre qu√© dos registros debe estar el nuevo registro del archivo.
- 2. Escribir el registro en una zona libre de memoria.
- 3. Asignar al nuevo registro como puntero la direcci√≥n f√≠sica del registro siguiente.
- 4. Modificar el registro anterior para actualizar el valor de su puntero de forma que contenga la direcci√≥n del nuevo registro.
- ÔÇß Borrado. Para borrar un registro se asigna al puntero del registro anterior la direcci√≥n del registro siguiente al que se desea borrar.
- ÔÇß Modificaci√≥n. Si el cambio no implica un aumento de longitud del registro, √©ste puede reescribirse en el mismo espacio. En caso contrario, se debe insertar el registro y luego borrar la versi√≥n anterior al cambio.

## Organizaci√≥n secuencial encadenada: ejemplo de inserci√≥n

## Se inserta un registro con llave "Gato

| Dir . Fisica   | LLave    | Puntero   |
|----------------|----------|-----------|
| 1              | Alba     |           |
| 2              | Elefante | 3         |
|                | Lcon     | 8         |
| 4              | Coral    | 2         |
| 5              | Mosca    | 6         |
| 6              | √ëu       | 7         |
| 7              | Pantera  | 0         |
| 8              | Morsa    | 5         |
| 10             |          |           |

| Dir . F√≠sica   | LLave    | Puntero   |
|----------------|----------|-----------|
| 1              | Alba     |           |
| 2              | Elefante | 3         |
| 3              |          | 8         |
| 4              | Coral    | 2         |
| 5              | Mosca    | 6         |
|                | √ëu       |           |
|                | Pantera  | 0         |
| 8              | Morsa    | 5         |
| 9              | Gato     | 3         |
| 10             |          |           |

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

|   Dir . F√≠sica | LLave    | Puntero   |
|----------------|----------|-----------|
|              1 | Alba     |           |
|              2 | Elefante |           |
|              3 | Leon     | 8         |
|              4 | Coral    | 2         |
|              5 | Mosca    | 6         |
|              6 | √ëu       | 7         |
|              7 | Pantera  | 0         |
|              8 | Morsa    | 5         |
|              9 | Gato     | 3         |
|             10 |          |           |

Paso 4

## Organizaci√≥n secuencial indexada [Prie06] (pp. 604-608)

Un archivo con organizaci√≥n secuencial indexada est√° formado por dos estructuras: zona de registros y zona de √≠ndices.

Zona de registros : es una zona donde se direccionan los registros del archivo; est√° dividida en tramos (conjunto de registros consecutivos). Los registros est√°n ordenados seg√∫n el valor de una llave.

Zona de √≠ndices : es una zona en la que por cada tramo de la zona de registros hay un registro que contiene:

- ¬∑ El mayor valor de la llave del tramo (valor de llave del √∫ltimo registro del tramo).
- ¬∑ La direcci√≥n del primer registro del tramo.

La gesti√≥n de la estructura la realiza el sistema operativo o un software especial, por lo que el usuario de esta estructura no necesita conocer la existencia de ambas zonas, pudiendo contemplar ambas como un todo.

Tema 4. Sistemas de archivos. Introducci√≥n a las bases de datos

## Organizaci√≥n secuencial indexada: ejemplo



## Organizaci√≥n secuencial indexada: operaciones sobre archivos

- ÔÇß Consulta. Se realiza por llave (esto es, localizar un registro conocida su llave) sin necesidad de leer los registros que no se encuentran en su mismo tramo. El procedimiento a seguir para realizar una consulta por llave es:
- 1. Leer secuencialmente las llaves en la zona de √≠ndices hasta encontrar una mayor o igual a la del registro buscado.
- 2. Obtener la direcci√≥n de comienzo del tramo donde est√° el registro.
- 3. Leer secuencialmente el tramo de la zona de registros a partir de la direcci√≥n obtenida en la zona de √≠ndices hasta encontrar el registro buscado o uno con valor de llave mayor que el buscado (en este √∫ltimo caso el registro no se encuentra en el archivo).

Tema 4. Sistemas de archivos. Introducci√≥n a las bases de datos

## Organizaci√≥n secuencial indexada: ejemplo

Consulta de un registro con llave 'Digital'.



## Organizaci√≥n secuencial indexada: operaciones sobre archivos

- ÔÇß Inserci√≥n. Dado que ambas zonas son secuenciales, no es posible insertar un registro en archivos con esta organizaci√≥n.
- ¬∑ En algunos casos se permite la escritura de nuevos registros al final de la zona de registros. Estos registros, como es l√≥gico, no podr√°n ser consultados por llave con el procedimiento descrito anteriormente.
- ÔÇß Borrado . Al estar los registros escritos en secuencia no es posible borrar un registro.
- ¬∑ La √∫nica forma de eliminar la informaci√≥n contenida en un registro es marc√°ndolo, lo que se conoce como borrado l√≥gico.
- ÔÇß Modificaci√≥n . Las modificaciones son posibles tan s√≥lo si el registro no aumenta de longitud al ser modificado y no se altera el valor de la llave del mismo.

## Organizaci√≥n directa o aleatoria [Prie06] (pp. 608-611)

Un archivo con organizaci√≥n directa o aleatoria (' random ') es un archivo escrito sobre un soporte de acceso directo para el cual existe una funci√≥n de transformaci√≥n que genera la direcci√≥n de cada registro en el archivo a partir de un campo que se usa como llave.

El nombre de 'aleatorio' se debe a que normalmente no existe ninguna vinculaci√≥n aparente entre el orden l√≥gico de los registros y su orden f√≠sico.

La organizaci√≥n directa es √∫til para archivos donde los accesos deben realizarse por llave, accedi√©ndose siempre a registros concretos.

Si la informaci√≥n se va a procesar en conjunto, con frecuencia puede ser m√°s rentable una organizaci√≥n secuencial indexada.

## Organizaci√≥n directa o aleatoria: problema de los sin√≥nimos

Un problema fundamental de esta organizaci√≥n es elegir adecuadamente la funci√≥n de  transformaci√≥n o m√©todo de direccionamiento que se va a utilizar ya que pueden darse las siguientes situaciones no deseadas:

- ¬∑ Que haya direcciones que no se corresponden con ninguna llave y, por tanto, habr√° zonas de disco sin utilizar.
- ¬∑ Que haya direcciones que se correspondan con m√°s de una llave. En este caso se dice que las llaves son sin√≥nimas para esa transformaci√≥n o que se produce una colisi√≥n.

Hay dos formas de resolver el problema de los sin√≥nimos , siempre a costa de complicar la estructura del archivo:

- ¬∑ Cuando se asocia a una llave una direcci√≥n ya ocupada por un registro distinto (esto es, por un sin√≥nimo de esta llave), se busca en el archivo hasta encontrar una posici√≥n libre donde escribir el registro.
- ¬∑ Se reserva una zona de desbordamiento donde se escribir√°n los registros que no se pueden escribir en la posici√≥n que les corresponde seg√∫n la transformaci√≥n. Esta zona se puede gestionar secuencialmente o encadenada a la zona principal de registros.

## Organizaci√≥n directa o aleatoria: m√©todos de direccionamiento

- 1) Direccionamiento directo. Se utiliza como direcci√≥n la propia llave y solo es factible cuando la llave es num√©rica y su rango de valores no es mayor que el rango de direcciones en el archivo.
- ¬∑ Por ejemplo, el archivo de habitaciones de un hotel puede organizarse en forma aleatoria con direccionamiento directo haciendo coincidir la direcci√≥n con el n√∫mero de habitaci√≥n.

Inconveniente : En algunos casos pueden quedar lagunas de direcciones sin utilizar, en lugares conocidos de antemano. En este caso se pueden ocupar dichas direcciones desplazando las direcciones superiores.

- 2) Direccionamiento asociado. Se puede utilizar cualquier tipo de llave. Si se utiliza este m√©todo debe construirse una tabla en la que se almacena para cada llave la direcci√≥n donde se encuentra el registro correspondiente. Dicha tabla se debe guardar mientras exista el archivo.

## Organizaci√≥n directa o aleatoria: m√©todos de direccionamiento

- 3) Direccionamiento calculado ('hashing'). La direcci√≥n de cada registro se obtiene realizando una transformaci√≥n sobre la llave.

## Se utiliza cuando:

- ¬∑ La llave no es num√©rica, en cuyo caso se necesita una conversi√≥n previa para obtener un n√∫mero a partir de ella.
- ÔÉº Por ejemplo se usa el equivalente decimal al propio c√≥digo binario del car√°cter (al car√°cter A le corresponder√≠a el 65, ...)
- ¬∑ La llave es num√©rica pero toma valores en un rango inadecuado para usarse directamente como direcci√≥n.

## Organizaci√≥n directa o aleatoria: operaciones sobre archivos

- ÔÇß Consulta. La consulta se realiza por llave. Para leer un registro debe aplicarse a la llave el algoritmo de transformaci√≥n, este algoritmo devuelve un n√∫mero que es la direcci√≥n del registro que se quiere leer.  Si el registro con la llave buscada no se encuentra all√≠, se proceder√° seg√∫n se haya resuelto la gesti√≥n de sin√≥nimos o colisiones.
- ÔÇß Borrado. Siempre se realiza un borrado l√≥gico, pudi√©ndose reutilizar el espacio del registro eliminado.
- ÔÇß Modificaci√≥n e inserci√≥n. Siempre se puede modificar o insertar un nuevo registro, realizando la transformaci√≥n de la llave correspondiente.

## 4.3  Bases de datos

Tema 4. Sistemas de archivos. Introducci√≥n a las bases de datos

Problem√°tica [Prie06] (pp. 617-628)

En una aplicaci√≥n convencional con archivos aparecen los siguientes problemas :

- 1. Dificultad de mantenimiento. Si hay archivos con informaci√≥n parcialmente duplicada, realizar las actualizaciones necesarias es un problema complejo y costoso. Normalmente, es necesario actualizar varios archivos con diferentes organizaciones. Si la actualizaci√≥n no se realiza correctamente se tendr√° informaci√≥n incoherente.
- 2. Redundancia. Se dice que hay redundancia si un dato se puede deducir a partir de otros datos (se dan los problemas explicados en el caso anterior).
- 3. Rigidez de b√∫squeda. El archivo se concibe para acceder a los datos de un modo determinado. Sin embargo, en la mayor√≠a de los casos es necesario (o al menos deseable) combinar acceso secuencial y directo por varias claves.

## Problem√°tica

- 4. Dependencia con los programas. En un archivo no est√°n reflejadas las archivo es quien determina en cada caso dichas relaciones.
- Esto ocurre aun en el caso de que la alteraci√≥n sea ajena al programa.  As√≠ por programas que no lo usan.
- relaciones existentes entre campos y registros. El programa que trabaja con el En consecuencia, cualquier modificaci√≥n de la estructura de un archivo obliga a modificar todos los programas que lo usen. ejemplo, si se aumenta la longitud de un campo habr√° que modificar incluso los
- 5. Seguridad. Uno de los mayores problemas de cualquier sistema de informaci√≥n es mantener la seguridad necesaria sobre los datos que contiene.
- Si se est√° trabajando con archivos, el control deber√° realizarlo el propio programa.
- El aspecto de la seguridad es particularmente deficitario en los sistemas de archivos.

## Concepto de Base de Datos [Prie06] (pp. 617-630)

Las bases de datos surgen como alternativa a los sistemas de archivos, intentando eliminar o al menos reducir sus inconvenientes.

Una base de datos es un sistema formado por un conjunto de datos y un paquete software para gesti√≥n de dicho conjunto de datos de tal modo que:

- ¬∑ Se controla el almacenamiento de datos redundantes.
- ¬∑ Los datos resultan independientes de los programas que los usan.
- ¬∑ Las relaciones entre los datos se almacenan junto a ellos.
- ¬∑ Se puede acceder a los datos de diversas formas.

La forma en la que se almacenan las relaciones entre datos y el utilizar como unidad de almacenamiento el campo adem√°s del registro, es el fundamento de la independencia respecto a los programas de aplicaci√≥n.

## Requisitos que deben cumplir las Bases de Datos

- 1. Acceso m√∫ltiple. Diversos usuarios pueden acceder a la base de datos, sin que se produzcan conflictos, ni visiones incoherentes.
- 2. Utilizaci√≥n m√∫ltiple. Cada usuario podr√° tener una imagen o visi√≥n particular de la estructura de la base de datos.
- 3. Flexibilidad. Se podr√°n usar distintos m√©todos de acceso, con tiempos de respuesta razonablemente peque√±os.
- 4. Seguridad. Se controlar√° el acceso a los datos (a nivel de campo), impidi√©ndoselo a los usuarios no autorizados.
- 5. Protecci√≥n contra fallos. Deben existir mecanismos concretos de recuperaci√≥n en caso de fallo de la computadora.

## Requisitos que deben cumplir las Bases de Datos

- 6. Independencia f√≠sica. Se puede cambiar el soporte f√≠sico de la base de datos sin que esto repercuta en la base de datos ni en los programas que la utilizan.
- 7. Independencia l√≥gica. Se pueden modificar los datos contenidos en la base, las relaciones existentes entre ellos o incluir nuevos datos, sin afectar a los programas que la usan.
- 8. Redundancia controlada. Los datos se almacenan una sola vez.
- 9. Interfaz de alto nivel. Existe una forma sencilla y c√≥moda de utilizar la base al menos desde un lenguaje de programaci√≥n de alto nivel.
- 10. Interrogaci√≥n directa (' query '). Existe una utilidad que permite el acceso a los datos de forma interactiva o conversacional.

Tema 4. Sistemas de archivos. Introducci√≥n a las bases de datos

## Estructura de una Base de Datos

Se dice que uno o m√°s atributos de una entidad es un identificador o clave primaria si el valor de dichos atributos determina de forma un√≠voca cada uno de los elementos de dicha entidad, y no existe ning√∫n subconjunto de √©l que permita identificar a la entidad de manera √∫nica.

En una base de datos se almacenan adem√°s de las entidades, las relaciones existentes entre ellas.

En la implementaci√≥n de la base de datos, estas relaciones se almacenan con punteros que inserta autom√°ticamente el software que la maneja y esto es "transparente" al usuario.

## Niveles de abstracci√≥n de la informaci√≥n: vistas y esquemas

- ¬∑ Nivel de vista . Permite describir diferentes vistas o subesquemas , cada una de las cuales se corresponde con la parte de la base de datos que interesa a un determinado grupo de usuarios. Adem√°s limita el acceso solo a la informaci√≥n de la vista.
- ¬∑ Nivel conceptual . Describe el esquema de la base de datos . En √©ste se especifica qu√© informaci√≥n se guarda en la base de datos, incluyendo todos los datos almacenados en ella y las relaciones entre ellos. Este nivel se utiliza en la administraci√≥n de la base de datos.
- ¬∑ Nivel f√≠sico . Describe c√≥mo se almacenan los datos, con las estructuras de datos necesarias para ello.



Tema 4. Sistemas de archivos. Introducci√≥n a las bases de datos

## Modelos de datos

Modelo de datos : grupo de herramientas conceptuales que permite describir los datos, sus relaciones, su sem√°ntica y sus limitaciones. Ayuda a describir la estructura de una base de datos.

Clasificaci√≥n de los modelos de datos:

- ¬∑ Modelos l√≥gicos basados en objetos . Describen los datos a nivel conceptual y a nivel de vista, permiten una estructuraci√≥n flexible y especificar limitaciones de los datos. Caso a tratar: Modelo entidad-relaci√≥n.
- ¬∑ Modelos l√≥gicos basados en registros .  Describen los datos a nivel conceptual y a nivel de vista, permitiendo especificar la estructura l√≥gica pero no las limitaciones de los datos. Casos a tratar: Modelo jer√°rquico, Modelo en red y Modelo relacional.
- ¬∑ Modelos f√≠sicos de los datos . Describen los datos en el nivel de implementaci√≥n de los sistemas de base de datos.

## Modelo entidad-relaci√≥n: conceptos b√°sicos

- ¬∑ Entidad : objeto que tiene existencia propia, que puede distinguirse de otros y del cu√°l se quiere almacenar informaci√≥n de ciertas caracter√≠sticas. Ejemplo: Pepe con DNI 24324450 y que vive en Granada.
- ¬∑ Conjunto de entidades : grupo de entidades del mismo tipo que representa la estructura gen√©rica de una entidad de inter√©s. Las entidades pueden pertenecer a m√°s de un conjunto de entidades. Ejemplo: Cliente.
- ¬∑ Relaci√≥n : asociaci√≥n entre varias entidades. Ejemplo: El cliente con DNI 24324450 compra un coche con matricula 6670 BBC el 7/11/2005.
- ¬∑ Conjunto de relaciones : grupo de relaciones del mismo tipo que representa la estructura gen√©rica de las relaciones entre conjuntos de entidades. Ejemplo: Compra.
- ¬∑ Grado de una relaci√≥n : n√∫mero de tipos de entidad que intervienen en un tipo de relaci√≥n. Ejemplo: En el caso de la relaci√≥n en la que un cliente compra un coche, el grado de la relaci√≥n es 2.
- ¬∑ Atributo : unidad b√°sica de informaci√≥n sobre un tipo de entidad o un tipo de relaci√≥n. Ejemplos: DNI, Nombre, Direcci√≥n, Fecha de compra.

## Modelo entidad-relaci√≥n: tipos de correspondencias (cardinalidad)

Cardinalidad : expresa el n√∫mero de entidades con las que puede asociarse o corresponderse una determinada entidad mediante una relaci√≥n.

En el caso de un conjunto binario de relaciones R entre los conjuntos de relaciones A y B, los tipos de correspondencias o cardinalidades pueden ser:

- ¬∑ Uno a uno (1:1) : a cada entidad de A le puede corresponder una √∫nica entidad de B y viceversa.
- ¬∑ Uno a muchos (1:N): a cada entidad de A le puede corresponder m√°s de una entidad de B, pero cada entidad de B solo puede asociarse con una √∫nica entidad de A.
- ¬∑ Muchos a uno (N:1): a cada entidad de A le puede corresponder una √∫nica entidad de B, pero cada entidad de B puede asociarse con varias entidades de A.
- ¬∑ Muchos a muchos (N:M): a cada entidad de A le puede corresponder m√°s de una entidad de B, y a cada entidad de B le puede corresponder m√°s de una entidad de A.

## Modelo entidad-relaci√≥n: Diagrama entidad-relaci√≥n

Diagrama entidad-relaci√≥n : representaci√≥n gr√°fica de la estructura de una base de datos organizada seg√∫n el Modelo entidad-relaci√≥n.

## Sus componentes principales son:

- ¬∑ Rect√°ngulos : representan conjuntos de entidades.
- ¬∑ Rombos : representan conjuntos de relaciones.
- ¬∑ Elipses : representan atributos (de conjuntos de entidades o de conjuntos de relaciones).
- ¬∑ Representaci√≥n de la cardinalidad . Se puede hacer de varias maneras:
- ¬∑ Con una etiqueta asociada al conjunto de relaciones (solo para relaciones binarias).
- ¬∑ Poniendo una punta de flecha que se√±ale hacia el conjunto de relaciones que participa de forma 'uno' y usando una l√≠nea sin punta en el caso de conjuntos de entidades que participan de forma 'muchos'.

## Modelo entidad-relaci√≥n: ejemplos de diagrama entidad-relaci√≥n



## Modelos l√≥gicos basados en registros: tipos de Bases de Datos

## 1) Modelo de datos jer√°rquico.

Permite especificar una base de datos jer√°rquica , donde se establece una relaci√≥n jer√°rquica entre los datos en forma de √°rbol, y no es posible definir relaciones muchos a muchos.



## 2) Modelo de datos en red.

Permite especificar una base de datos en red , donde pueden darse relaciones binarias con cualquier cardinalidad (1:1, 1:N, N:1, N:M) y no es necesario que la estructura tenga forma de √°rbol.

## Modelos l√≥gicos basados en registros: tipos de Bases de Datos

## 3) Modelo de datos relacional.

Permite especificar una base de datos relacional , que estar√° formada por tablas. Una tabla es una estructura bidimensional formada por una sucesi√≥n de registros del mismo tipo.

Si se imponen ciertas condiciones a las tablas, se pueden tratar como relaciones matem√°ticas .

Las tablas deben cumplir las siguientes condiciones:

- 1. Todos los registros de una tabla son del mismo tipo. Para almacenar registros de tipos distintos se usan tablas distintas.
- 2. En ninguna tabla aparecen campos repetidos.
- 3. En ninguna tabla existen registros duplicados.
- 4. El orden de los registros en la tabla es indiferente. En cada momento se pueden recuperar los registros en un orden particular.
- 5. En cada tabla hay una llave, formada por uno o varios campos.

## Modelos l√≥gicos basados en registros: tipos de Bases de Datos

- 3) Modelo de datos relacional: ejemplo tablas.

## Equipos

| Cod_equipo   | Nombre   | Localidad   |
|--------------|----------|-------------|
|              | Mazorcos |             |
| 2            | Dehesa   | Madrid      |
| 3            | Canaleja | Alcorc√≥n    |

## Jugadores

|   Cod_jugador |   Cod_equipo | Nombre          |   Edad |
|---------------|--------------|-----------------|--------|
|             1 |            1 | Luis Valderrama |     42 |
|             2 |            1 | Ra√∫l Turri√≥n    |     35 |
|             3 |            2 | Luis Fern√°ndez  |     40 |
|             4 |            3 | Isaac S√°nchez   |     43 |
|             5 |            3 | Dimas Moreno    |     31 |

## Transformaci√≥n del Modelo entidad-relaci√≥n al Modelo de datos relacional

Dado un Diagrama entidad-relaci√≥n, el paso a tablas o relaciones del Modelo de datos relacional se efect√∫a como sigue:

- ¬∑ Conjuntos de entidades:
- ¬∑ Se define una tabla para cada conjunto de entidades.
- ¬∑ Para cada atributo se define una columna en la tabla.
- ¬∑ Conjuntos de relaciones sin atributos propios:
- ¬∑ Cardinalidad 1:1: En la tabla de uno de los conjuntos de entidades (el que se considere principal) se a√±aden las columnas necesarias para albergar los atributos que forman la clave del otro conjunto de entidades.
- ¬∑ Cardinalidad 1:N o N:1: En la tabla del conjunto de entidades que participa de forma 'muchos' se a√±aden las columnas necesarias para albergar los atributos que forman la clave del otro conjunto de entidades.
- ¬∑ Cardinalidad N:M: Se define una tabla propia para el conjunto de relaciones y, en ella, se definen las columnas necesarias para albergar los atributos que forman la clave de cada uno de los conjuntos de entidades que relaciona ese conjunto de relaciones.

## Transformaci√≥n del Modelo entidad-relaci√≥n al Modelo de datos relacional

## ¬∑ Conjuntos de relaciones con atributos propios:

- ¬∑ Cardinalidad 1:1, 1:N o N:1: Se puede seguir el mismo enfoque dado para conjuntos de relaciones sin atributos propios, pero a√±adiendo tambi√©n las columnas necesarias para albergar los atributos del conjunto de relaciones en la misma tabla del conjunto de entidades donde se a√±ada la clave del otro conjunto de entidades. Esta forma est√° desaconsejada desde el punto de vista conceptual y por cuestiones de mantenimiento del software.
- ¬∑ Cardinalidad N:M, 1:1, 1:N o N:1 : Se define una tabla propia para el conjunto de relaciones y, en ella, se definen las columnas necesarias para albergar los atributos que forman la clave de cada uno de los conjuntos de entidades que relaciona ese conjunto de relaciones; en esa misma tabla, adem√°s, se definen las columnas necesarias para albergar los atributos propios del conjunto de relaciones.

Tema 4. Sistemas de archivos. Introducci√≥n a las bases de datos

## Transformaci√≥n del Modelo entidad-relaci√≥n al Modelo de datos relacional: ejemplos



## Cliente

Coche

## Compra

DNI

Nombre

Direcci√≥n

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

Matr√≠cula

Marca

DNI

Matr√≠cula

Fecha

Tema 4. Sistemas de archivos. Introducci√≥n a las bases de datos

## Transformaci√≥n del Modelo entidad-relaci√≥n al Modelo de datos relacional: ejemplos



## M√©dico

## Paciente

N¬∫ de colegiado

Nombre

DEPARTAMENTO DE \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

N¬∫ de tarjeta sanitaria

N¬∫ de colegiado

Nombre

Direcci√≥n

## 4.4 Sistema de gesti√≥n de la base de datos

## Definici√≥n de sistema de gesti√≥n de base de datos

Sistema de gesti√≥n de la base de datos - SGBD ("Data Base Management System" - DBMS): conjunto de software destinado a la creaci√≥n, control y manipulaci√≥n de la informaci√≥n de una base de datos.

Un SGBD debe permitir la realizaci√≥n de las siguientes tareas :

- 1. Definici√≥n del esquema de la base de datos y de los distintos subesquemas.
- 2. Acceso a los datos desde alg√∫n lenguaje de alto nivel.
- 3. Interrogaci√≥n (o recuperaci√≥n de la informaci√≥n) directa en modo conversacional.
- 4. Organizaci√≥n f√≠sica de la base de datos y recuperaci√≥n tras fallos del sistema.

Tema 4. Sistemas de archivos. Introducci√≥n a las bases de datos

## Lenguajes espec√≠ficos en un SGBD

Las tres primeras tareas se realizan mediante dos lenguajes espec√≠ficos:

- ¬∑ Lenguaje de descripci√≥n de datos  DDL ( , "Data Description Language¬ª ). Se usa para la descripci√≥n del esquema y de los subesquemas.
- ¬∑ Lenguaje de manipulaci√≥n de datos  DML ( , "Data Manipulation Language¬ª). Se utiliza para el acceso a la base de datos desde lenguajes de alto nivel o en modo conversacional.
- El sistema de gesti√≥n de la base de datos act√∫a como intermediario entre los programas de aplicaci√≥n y el sistema operativo, lo que permite que los programas sean independientes de la estructura f√≠sica de los datos.
```



## üìÑ Archivo: [Teor√≠a] Transp.Tema5.GeneracionDepuracionAplicaciones_2000.pdf

**M√©todo de extracci√≥n usado:** Docling

```markdown
1er Curso del Doble Grado en Ingenier√≠a Inform√°tica y ADE

## Tema 5. Generaci√≥n y Depuraci√≥n de Aplicaciones





- 5.1 Concepto de plataforma. Software
- independiente de plataforma
- 5.2 Plataformas para el desarrollo de aplicaciones
- 5.3 T√©cnicas de depuraci√≥n de programas
- ¬∑ Conocer conceptos y propiedades de calidad (portabilidad, productividad, etc.) a incorporar en el proceso de desarrollo de software.
- ¬∑ Conocer los fundamentos de los procesos de generaci√≥n y depuraci√≥n de aplicaciones.
- ¬∑ Conocer t√©cnicas a aplicar en las diferentes fases de generaci√≥n y desarrollo de programas.
- ¬∑ Comprender la importancia de plataformas y entornos de desarrollo y depuraci√≥n de aplicaciones.

## Bibliograf√≠a b√°sica

- ¬∑ [Agans06] David J. Agans: ' Debugging: The 9 Indispensable Rules for Finding Even the Most Elusive Software and Hardware Problems ', Amacom, 2006
- Disponible en:
- ¬∑ [Bottcher18] Evan Bottcher. ' What I Talk About When I Talk About Platforms'. https://martinfowler.com/articles/talk-about-platforms.html (√öltimo acceso: Abril 2020)
- ¬∑ [Dooley16] John F. Dooley. ' Software Development, Design and Coding: With Patterns, Debugging, Unit Testing, and Refactoring ', Apress, 2017
- ¬∑ [Stallman18] Richard Stallman, Roland Pesch, Stan Shebs. ' Debugging with GDB: The GNU Source-Level Debugger ', 12th Media Services, 2018
- ¬∑ [Zeller09] A. Zeller: 'Why Programs Fail ' (2nd Edition), Morgan Kaufmann Publishers (Elsevier), 2009

## 5.1 Plataforma

Tema 4. Generaci√≥n y depuraci√≥n de aplicaciones

## Concepto de Plataforma

Plataforma: Combinaci√≥n de hardware y/o software utilizada para ejecutar aplicaciones software.

La versi√≥n m√°s simple de plataforma puede ser una arquitectura de computadora o sistema operativo. Otros ejemplos son los navegadores web y sus plugin asociados, las m√°quinas virtuales (ejemplo, JVM), las plataformas de computaci√≥n en la nube (Amazon Web Services, Google Cloud, Microsoft Azure, IBM Bluemix, etc.).

Ejemplos de plataformas:

| Sistema Operativo   | Arquitectura Hardware                                                                                               |
|---------------------|---------------------------------------------------------------------------------------------------------------------|
| Microsoft Windows   | x86                                                                                                                 |
| Linux/Unix          | X86, RISC, SPARC                                                                                                    |
| Mac OS X            | X86, PowerPC                                                                                                        |
| Android             | Dispositivos m√≥viles basados en arquitecturas  ARM, MIPS y x86                                                      |
| Java                | M√∫ltiples SOs para los que existen  implementaciones de Java Virtual Machine , y  por tanto m√∫ltiples arquitecturas |

## 5.1 Plataforma

Tema 4. Generaci√≥n y depuraci√≥n de aplicaciones

## Clasificaci√≥n del software

En cuanto a plataformas, el software se puede clasificar como:

- 1. Dependiente de la plataforma particular para la cual se desarrolla y ejecuta (bien sea una plataforma hardware, sistema operativo o m√°quina virtual)
- 2. Multiplataforma, cuando el software se ha desarrollado e interopera en varias plataformas.

Una aplicaci√≥n multiplataforma se puede ejecutar en:

- 1. tantas plataformas como existan (caso ideal de software independiente de la plataforma ), o
- 2. tan s√≥lo en dos plataformas diferentes, por ejemplo, una aplicaci√≥n multiplataforma se podr√≠a ejecutar en Microsoft Windows y Linux en arquitecturas x86.

## 5.1 Plataforma

## Software multiplaforma

- El software multiplataforma puede dividirse en dos tipos :
- 1. Aplicaciones que requieren su creaci√≥n o compilaci√≥n para cada plataforma espec√≠fica donde se ejecutar√°n.
- 2. Aplicaciones que directamente se pueden ejecutar en m√°s de una plataforma sin preparaci√≥n especial (p. ej., plataforma Java):

Aplicaciones  escritas  en  un lenguaje interpretado (o precompilado en un c√≥digo intermedio) portable: el int√©rprete y  los  paquetes  para  su  ejecuci√≥n  son est√°ndares para varias plataformas.

Fuente figura:



http://parasitovirtual.wordpress.com/2010/09/23/introduccion-a-java/

Tema 4. Generaci√≥n y depuraci√≥n de aplicaciones

## 5.1 Plataforma

Tema 4. Generaci√≥n y depuraci√≥n de aplicaciones

## Plataforma Java (1/3)

Ejemplo de plataforma a mayor nivel de abstracci√≥n (incluye lenguaje de programaci√≥n) que el proporcionado por un sistema operativo.

Java 2 Platform Standard Edition 5.0



Fuente figura: http://luizgustavoss.wordpress.com/2009/02/06/visao-geral-da-tecnologia-java/

## 5.1 Plataforma

Tema 4. Generaci√≥n y depuraci√≥n de aplicaciones

## Plataforma Java (2/3)

- ¬∑ Requiere m√°quina virtual JVM ( Java Virtual Machine ): el mismo c√≥digo se puede ejecutar en todos los sistemas que implementen JVM.
- ¬∑ Los ejecutables Java no se ejecutan nativamente sobre el sistema operativo, es decir, ni Windows, Linux, Mac OS X, etc, ejecutan programas Java directamente. Sin embargo, Java Native Interface (JNI) permite el acceso a funciones espec√≠ficas del sistema operativo.
- ¬∑ Para aplicaciones Java m√≥viles : Windows y Mac OS utilizan plugins en los navegadores para su ejecuci√≥n; y Android soporta Java directamente.





## Fuente figura:

http://profejavaoramas.blogspot.com.es/201 0/04/maquina-virtual-de-java-jvm.html

## 5.1 Plataforma

Tema 4. Generaci√≥n y depuraci√≥n de aplicaciones

## Plataforma Java (3/3)

- ¬∑ JVM ejecuta programas Java compilados a lenguaje intermedio ( bytecodes ) independiente de hardware y sistema operativo donde se ejecuta; los programas Java son multiplataforma , pero no la JVM (hay una para cada sistema operativo).
- ¬∑ Hay un compilador JIT ( Just In Time ) dentro de la JVM ( desde la version 1.2) que traduce Java bytecodes en instrucciones nativas del procesador en tiempo de ejecuci√≥n, las cuales se almacenan para su posterior reutilizaci√≥n.
- ¬∑ El uso del compilador JIT permite que, despu√©s de un breve retardo en la carga y pr√°cticamente su total compilaci√≥n, las aplicaciones Java se ejecuten tan r√°pidamente como programas nativos .



## 5.1 Plataforma

## Plataforma Android (1/3)

- ¬∑ La arquitectura de Android est√° formada por distintas capas, todas ellas basadas en software libre. Cada una de las capas utiliza elementos de la capa inferior para realizar sus funciones (pila de software):
- ¬∑ Kernel de Linux . Es la base de la plataforma Android: generaci√≥n de subprocesos, administraci√≥n de memoria de bajo nivel, funciones de seguridad claves, etc.

Tema 4. Generaci√≥n y depuraci√≥n de aplicaciones

Dialer

Package

View

|                 |           | Libc   | Android Runtime (ART)   |
|-----------------|-----------|--------|-------------------------|
| Media Framework | OpenGL ES |        | Core Libraries          |

## Hardware Abstraction Layer (HAL)

Audio

Bluetooth

Camera

Sensors

- ¬∑ Capa de abstracci√≥n de hardware (HAL). M√≥dulos de biblioteca que implementan interfaces para un tipo espec√≠fico de componente de hardware (ej. m√≥dulo de la c√°mara o de Bluetooth).



Fuente figura: https://developer.android.com/guide/platform

## 5.1 Plataforma

## Plataforma Android (2/3)

- ¬∑ Tiempo de ejecuci√≥n de Android (ART). El Ejecuta varias m√°quinas virtuales en dispositivos de memoria baja utilizando archivos DEX (formato de c√≥digo de bytes dise√±ado especialmente para Android y optimizado para ocupar un espacio de memoria m√≠nimo).

## Fundamentos del Software

Tema 4. Generaci√≥n y depuraci√≥n de aplicaciones







- ¬∑ Bibliotecas C/C++ nativas. Muchos componentes y servicios centrales del sistema Android, como el ART y la HAL, se basan en c√≥digo nativo que requiere bibliotecas nativas escritas en C y C++.





Fuente figura: https://developer.android.com/guide/platform

## 5.1 Plataforma

## Plataforma Android (3/3)

- ¬∑ Marco de trabajo de la API de Java. El conjunto de funciones del SO Android est√° disponible mediante API escritas en lenguaje Java, necesarias para crear apps de Android simplificando la reutilizaci√≥n de componentes del sistema y servicios centrales y modulares.
- ¬∑ Apps del sistema. Se incluye un conjunto de apps centrales para correo electr√≥nico, mensajer√≠a SMS, calendarios, navegaci√≥n en Internet y contactos, entre otros elementos. Las apps del sistema funcionan como apps para los usuarios y brindan capacidades claves a las cuales los desarrolladores pueden acceder desde sus propias apps.

|                 | OpenMAX AL   | Libc   | Android Runtime (ART)   |
|-----------------|--------------|--------|-------------------------|
| Media Framework | OpenGL ES    |        | Core Libraries          |



Fuente figura: https://developer.android.com/guide/platform

## 5.2  Framework de Desarrollo de Aplicaciones

Tema 4. Generaci√≥n y depuraci√≥n de aplicaciones

## Herramientas b√°sicas para el desarrollo software en Linux

| Fases                                  | Herramientas                                                                                                                                                                                                                                                           |
|----------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Generador de c√≥digo fuente             | Editores de texto ( pico ,  emacs ,  xemacs , ‚Ä¶)                                                                                                                                                                                                                       |
| Sangrado c√≥digo fuente                 | indent  sangra un programa en C sint√°cticamente correcto                                                                                                                                                                                                               |
| Compilaci√≥n c√≥digo fuente              | gcc  y  g++  de GNU pre-procesa, compila, optimiza, y enlaza para generar  archivos ejecutables                                                                                                                                                                        |
| Gesti√≥n de software basado  en m√≥dulos | make  actualiza archivos en base a relaciones de dependencia previamente  almacenadas                                                                                                                                                                                  |
| Gesti√≥n de bibliotecas                 | ‚Ä¢ ar  permite crear y manipular archivadores en base a conjunto de archivos  ‚Ä¢ ranlib  genera y a√±ade una tabla de √≠ndice de contenidos a archivadores  acelerando la fase de enlazado  ‚Ä¢ nm  visualiza informaci√≥n de archivos objeto que ayuda a depurar bibliotecas |
| Control de versiones                   | CVS (Sistema Concurrente de Versiones) es una interfaz a RCS (Sistemas de  Control de Revisiones), permite gesti√≥n de versiones en m√∫ltiples directorios y  con m√∫ltiples desarrolladores                                                                              |

## 5.2  Framework de Desarrollo de Aplicaciones

Tema 4. Generaci√≥n y depuraci√≥n de aplicaciones

## Integrated Development Environment (IDE)

- ¬∑ Entorno integrado de desarrollo (IDE): aplicaci√≥n que proporciona un conjunto de herramientas relacionadas para el desarrollo del software:
- ¬∑ creaci√≥n y edici√≥n de c√≥digo fuente;
- ¬∑ generadores (compiladores, interpretes, enlazadores, gestores de bibliotecas, etc) de c√≥digo objeto;
- ¬∑ despliegue y depuraci√≥n de programas.
- ¬∑ La integraci√≥n de herramientas contrasta con el desarrollo utilizando las herramientas aisladas que incluye Linux ( gcc make , , ‚Ä¶)
- ¬∑ IDEs ejemplo : Microsoft Visual Studio, Eclipse, SharpDevelop , etc.
- ¬∑ IDEs actuales para el desarrollo de software orientado a objetos ( ej: Netbeans ) incluyen otras herrramientas adicionales: navegadores para diagramas de jerarqu√≠a de clases, inspectores de objetos, etc.

## 5.2  Framework de Desarrollo de Aplicaciones

Tema 4. Generaci√≥n y depuraci√≥n de aplicaciones

## Objetivos de un IDE

- ¬∑ M√°ximizar la productividad de los programadores con herramientas provistas de interfaces de usuario similares: todo el desarrollo se lleva a cabo bajo una misma aplicaci√≥n.
- ¬∑ Reducir tareas de configuraci√≥n de m√∫ltiples herramientas proporcionando un conjunto de facilidades de forma cohesiva .
- ¬∑ Aprender rapidamente a utilizar un IDE que integra manualmente todas las herramientas.
- ¬∑ Acelerar el aprendizaje de lenguajes de programaci√≥n , por ejemplo, el c√≥digo se puede analizar mientras se edita para conocer de forma inmediata errores l√©xicos, sint√°cticos, etc.

## 5.2  Framework de Desarrollo de Aplicaciones

Tema 4. Generaci√≥n y depuraci√≥n de aplicaciones

## Tipos de IDE

- 1. Dedicados a un s√≥lo lenguaje de programaci√≥n y con un conjunto de caracter√≠ticas propias del paradigma de programaci√≥n al cual pertenece (p. ej. herramienta para manejo de jerarqu√≠a de clases en orientaci√≥n a objetos).
- 2. IDEs que soportan m√∫ltiples lenguajes de programaci√≥n :
- a) Alternativamente mediante plugins (es posible instalar varios lenguajes al mismo tiempo): Los IDEs Eclipse y Netbeans soportan entre otros C/C++, Ada, Perl, Python, Ruby, y PHP; o
- a) Al mismo tiempo para un conjunto de lenguajes/plataformas relacionados: Microsoft Visual Studio y Xcode (OS X/iOS y lenguajes C/C++, Objective-C, Java, AppleScript, Python, ‚Ä¶)

## 5.2  Framework de Desarrollo de Aplicaciones

## IDE ejemplo: NetBeans para Java



Fuente figura: http://www.nacho-alvarez.es/blog/2008/10/13/problema-con-sun-wireless-toolkit-bajonetbeans-ventana-en-blanco/

## 5.2  Framework de Desarrollo de Aplicaciones

Tema 4. Generaci√≥n y depuraci√≥n de aplicaciones

## IDEs y Programaci√≥n Visual

- ¬∑ La programaci√≥n visual hace uso de IDEs que permiten a los dise√±adores/programadores crear nuevas aplicaciones combinando bloques/nodos de c√≥digo mediante diagramas de estructura y de flujos, normalmente basados en el lenguaje UML ( Unified Modeling Language, https://www.uml.org/ )

## ¬∑ Ejemplos :

- 1. Lego Mindstorms System : utilizando la potencia de navegadores como Mozilla.
- 2. KTechlab :IDE abierto y simulador para desarrollar software para microcontroladores.
- 3. LabVIEW y EICASLAB : especializados en programaci√≥n distribuida.

## 5.2  Framework de Desarrollo de Aplicaciones

Tema 4. Generaci√≥n y depuraci√≥n de aplicaciones

## Framework de desarrollo software

- ¬∑ Framework de desarrollo software : abstracci√≥n que proporciona software con funcionalidad gen√©rica que puede cambiarse selectivamente mediante c√≥digo de usuario para la creaci√≥n de aplicaciones.
- ¬∑ Incluye herramientas similares a las encontradas en IDEs (compiladores, bibliotecas, etc.), as√≠ como una API ( Application Programming Interface ).
- ¬∑ Un framework tiene caracteristicas clave para la reutilizaci√≥n software que lo distinguen de otras alternativas tales como bibliotecas o bloques/nodos de c√≥digo en IDEs.

## 5.2  Framework de Desarrollo de Aplicaciones

Tema 4. Generaci√≥n y depuraci√≥n de aplicaciones

## Objetivos de un framework

- ¬∑ Facilitar y reducir el tiempo el desarrollo evitando dedicar tiempo a detalles de bajo nivel.
- ¬∑ Por ejemplo, un desarrollador debe escribir la funcionalidad para la gesti√≥n de un sistema bancario en Web en lugar de los mecanismos para manejar peticiones y gesti√≥n de estado tales como crear hebras para atender una nueva petici√≥n cuando el resto de hebras ya sirven otras peticiones previas.
- ¬∑ Debido a la complejidad de las APIs, un framework conlleva un tiempo extra de aprendizaje inicialmente.
- ¬∑ Generalmente los frameworks se centran en dominios espec√≠ficos : compiladores para diferentes lenguajes y plataformas, sistemas de soporte a la decisi√≥n, middleware, computaci√≥n de altas prestaciones.

## 5.2  Framework de Desarrollo de Aplicaciones

Tema 4. Generaci√≥n y depuraci√≥n de aplicaciones

## Caracter√≠sticas de un framework

- ¬∑ Inversion de control: a diferencia de las bibliotecas o aplicaciones normales, el c√≥digo del framework invoca al c√≥digo proporcionado por el usuario del framework.
- ¬∑ El framework tiene un comportamiento √∫til por defecto .
- ¬∑ Extensibilidad : un framework puede ser ampliado sobreescribiendo de forma selectiva o especializa su c√≥digo con la funcionalidad  espec√≠fica proporcionada por el usuario.
- ¬∑ El c√≥digo del framework no puede ser modificado, excepto por extensibilidad (como se ha comentado en el punto anterior).

## 5.2  Framework de Desarrollo de Aplicaciones

Tema 4. Generaci√≥n y depuraci√≥n de aplicaciones

## Arquitectura de un framework

- ¬∑ Un framework se define mediante componentes b√°sicos , y las relaciones entre ellos, que no pueden ser modificados ( frozen spots ).
- ¬∑ Existen partes predeterminadas donde el programador a√±ade su c√≥digo con la funcionalidad espec√≠fca deseada ( hot spots ).
- ¬∑ Ejemplo de arquitectura de un framework orientado a objetos:
- o El framework consta de clases abstractas y concretas, y su instanci√≥n consiste en componer y especializar dichas clases.
- o Las clases definidas por el usuario reciben mensajes de las clases del frameword (inversi√≥n de control); los desarrolladores manejan √©sto implementando los m√©todos abstractos de la superclase.

## 5.3  T√©cnicas de Depuraci√≥n de Programas

Tema 4. Generaci√≥n y depuraci√≥n de aplicaciones

## Definici√≥n y objetivos

- ¬∑ Depuraci√≥n : es una actividad compleja consistente en encontrar y solucionar errores cometidos en el dise√±o y codificaci√≥n de programas.
- ¬∑ Objetivos de las t√©cnicas aplicadas a la depuraci√≥n:
- o Incrementar la productividad encontrando y solucionando errores m√°s rapida y efectivamente.
- o Mejorar la calidad de los programas eliminando defectos.
- o Prevenir errores como mejor soluci√≥n.
- o Mejorar lenguajes de programaci√≥n y herramientas identificando errores est√°ticamente y detectando el incumplimiento de invariantes din√°micamente, e.g., definici√≥n de sistemas de tipos en Java y C#.

## 5.3  T√©cnicas de Depuraci√≥n de Programas

Tema 4. Generaci√≥n y depuraci√≥n de aplicaciones

## Fases para la generaci√≥n de fallos

- ¬∑ Creaci√≥n de un defecto : Pieza de c√≥digo creada por el programador que puede causar infecci√≥n como consecuencia de un error, cambios en los requisitos originales, o interacciones impredecibles entre componentes (p. ej. programas distribuidos).
- ¬∑ El defecto produce infecci√≥n . Los estados  a alcanzar en la ejecuci√≥n del programa difieren de los previstos por el programador.
- ¬∑ Propagaci√≥n de la infecci√≥n . Como un programa accede a su estado actual para su ejecuci√≥n, una infecci√≥n se puede propagar a otros estados.
- ¬∑ La infecci√≥n causa el fallo : Error observable externamente en el comportamiento de un programa.

## 5.3  T√©cnicas de Depuraci√≥n de Programas

Tema 4. Generaci√≥n y depuraci√≥n de aplicaciones

## Ejecuci√≥n de un programa como secuencia de estados ( Fuente fig.: [Zeller09])

1



## 5.3  T√©cnicas de Depuraci√≥n de Programas

Tema 4. Generaci√≥n y depuraci√≥n de aplicaciones

## Propiedades en la generaci√≥n de fallos

- ¬∑ Un estado de programa viene definido por los valores de las variables y la posici√≥n de ejecuci√≥n (contador de programa).
- ¬∑ Cada estado determina los siguientes estados hasta alcanzar el estado final.
- ¬∑ Las pruebas muestran la presencia de defectos pero nunca la ausencia:
- o Hay defectos que no provocan infecciones, y hay infecciones que no provocan fallos.
- o La ausencia de fallos no implica ausencia de defectos.
- ¬∑ La cadena de infecci√≥n viene definida por la relaci√≥n causa-efecto desde el defecto a fallo; la depuraci√≥n consiste en identificar dicha cadena de infecci√≥n para eliminar el defecto.

## 5.3  T√©cnicas de Depuraci√≥n de Programas

## Fases de depuraci√≥n

- 1. Registrar el problema.
- 2. Reproducir el fallo (the failure) : m√°s complicado para programas no-deterministas y de larga ejecuci√≥n.
- 3. Automatizar y simplificar el caso de prueba.
- 4. Encontrar posibles origenes de la infecci√≥n.
- 5. Centrar la b√∫squeda en los or√≠genes m√°s probables.
- 6. Aislar la cadena de infecci√≥n.
- 7. Corregir el defecto: sencillo si est√° claro el defecto que produce el fallo.

Tema 4. Generaci√≥n y depuraci√≥n de aplicaciones

## 5.3  T√©cnicas de Depuraci√≥n de Programas

Tema 4. Generaci√≥n y depuraci√≥n de aplicaciones

## Caracter√≠sticas del proceso de depuraci√≥n

- ¬∑ Las fases 4-6 est√°n directamente relacionadas con comprender c√≥mo se produce el fallo .
- ¬∑ La depuraci√≥n es un problema de b√∫squeda en dos dimensiones:
- 1. Espacio : parte del estado (conjunto de variables) que est√° infectado.
- 2. Tiempo : cuando tiene lugar la infecci√≥n (estado).
- ¬∑ La b√∫squeda es de envergadura incluso para los programas sencillos:
- 1. Los estados pueden comprender muchas variables.
- 2. La ejecuci√≥n puede constar de muchos estados.

## 5.3  T√©cnicas de Depuraci√≥n de Programas

## Ejemplo de estado de ejecuci√≥n:

- ¬∑ compilador GNU.
- ¬∑ 44.000 variables (v√©rtices).
- ¬∑ aprox. 42.000 referencias entre variables (arcos) (Fuente: [Zeller09])



Tema 4. Generaci√≥n y depuraci√≥n de aplicaciones

## 5.3  T√©cnicas de Depuraci√≥n de Programas

## B√∫squeda del defecto (Fuente: [Zeller09])

- ¬∑ Se aplican dos principios b√°sicos para la b√∫squeda:
- 1. separar estados sanos de infectados, y
- 2. separar variables relevantes e irrelevantes.
- ¬∑ Un fallo puede ocurrir debido a ciertos valores de variables en estados anteriores (!), lo cual determina dependencias que ayudan a localizar el defecto .

Tema 4. Generaci√≥n y depuraci√≥n de aplicaciones



## 5.3  T√©cnicas de Depuraci√≥n de Programas

Tema 4. Generaci√≥n y depuraci√≥n de aplicaciones

## Programaci√≥n estructurada y depuraci√≥n

La construcci√≥n de programas estructurados ayuda de forma importante a la depuraci√≥n gracias a las siguientes caracter√≠sticas:

- 1. Contiene un conjunto de funciones bien definidas .
- 2. Utiliza construcciones iterativas (como while y for ) en vez de goto .
- 3. Utiliza variables que tienen un prop√≥sito y a las cuales se les ha dado un nombre significativo.
- 4. Utiliza tipos de datos estructurados para representar datos complejos.
- 5. Utiliza ADTs ( Abstract Data Type ) o directamente el paradigma de programaci√≥n orientado a objetos .

## 5.3  T√©cnicas de Depuraci√≥n de Programas

Tema 4. Generaci√≥n y depuraci√≥n de aplicaciones

## Depurador

Definici√≥n : Herramienta software que ayuda a ejecuci√≥n controlada de un programa para ayudar a encontrar el defectos que producen un fallos.

## Caracter√≠sticas :

- 1. Interactivo. Aunque se puede usar en modo batch , su rol principal es interactuar con el programador.
- 2. Proporciona un conjunto de instrucciones que indican las acciones de depuraci√≥n a realizar.
- 3. Permite detectar errores en tres categor√≠as :
- a. Sint√°cticos : detectados durante la fase de compilaci√≥n o la de enlazado.
- b. Ejecuci√≥n : p. ej., acceder fuera del espacio de direcciones asignadas ( segmentation fault ) o realizar una operaci√≥n de divisi√≥n por cero, ambas produciendo la terminaci√≥n del programa.
- c. L√≥gicos : p. ej., bucles que iteran m√°s o menos veces de las previstas.

## 5.3  T√©cnicas de Depuraci√≥n de Programas

Tema 4. Generaci√≥n y depuraci√≥n de aplicaciones

## Tipos de errores comunes

Los tipos de errores m√°s comunes que se producen cuando se programa son:

- 1. Escribir  c√≥digo  de  una  forma  desestructurada . Cuando  un  programa  se estructura  adecuadamente,  se  divide  el  problema  en  sub-problemas  sobre  los cuales  se  puede  trabajar  independientemente  (razonar  sobre  su  soluci√≥n  y probarla) y despu√©s  componer  las distintas partes. Esto facilita mucho  la depuraci√≥n posterior.
- 2. Programar sin pensar : Antes de comenzar a codificar hay que dise√±ar la soluci√≥n al  problema planteado, pensando las distintas alternativas de soluci√≥n posibles y entendiendo el algoritmo que se ha de seguir.
```



## üìÑ Archivo: [Ejercicios] ProblemasTema1.pdf

_(Procesamiento saltado: Enfoque actual en 'Teor√≠a')_



## üìÑ Archivo: [Ejercicios] ProblemasTema2-2.pdf

_(Procesamiento saltado: Enfoque actual en 'Teor√≠a')_



## üìÑ Archivo: [Ejercicios] ProblemasTema3-2.pdf

_(Procesamiento saltado: Enfoque actual en 'Teor√≠a')_



## üìÑ Archivo: [Ejercicios] ProblemasTema4-1.pdf

_(Procesamiento saltado: Enfoque actual en 'Teor√≠a')_



## üìÑ Archivo: [Pr√°cticas] M√≥dulo.I.√ìrdenes.Unix.y.Shell.Bash-1.pdf

_(Procesamiento saltado: Enfoque actual en 'Teor√≠a')_



## üìÑ Archivo: [Pr√°cticas] M√≥dulo.II.Compilaci√≥n.y.depuraci√≥n.de.programas.v1.pdf

_(Procesamiento saltado: Enfoque actual en 'Teor√≠a')_

